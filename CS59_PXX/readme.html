**DSL Project**

Author
=============

<div class="noheader firstcol">
                  |             
------------------|-------------
Team Members      | Owen Chen & Cody Zang
Computer + OS     | Windows 11 & macOS
Time to Complete  | ~6 hours so far
Additional Help   | Consulting w/ Prof. & TAs
</div>

Meeting Dates
================
* 7/12/2025, 3-5pm - initial meeting to complete P00
* 7/15/2025, 3:30-4pm - meeting with professor, recieved approval
* 7/23/2025, 5:00-8:30pm - meeting to design and test grammar
* ...

P00: Selection
================

Define the domain.
--------------------------------
Our domain is email automation. Oftentimes in professional settings, email templates and similar tools are used in order to save time communicating. Key considerations in this domain are ease of use/learning (because non-technical staff will be using these tools) and output reliability/correctness (as these emails will be going to clients and other staff). There do exist tools for this sort of task, but they are not languages (more on that later, see below), so our approach the problem seems not to have been done before. 

Define the problem.
--------------------------------
<b>Key Question:</b> What is the purpose of the language?

There are several key issues with existing automation tools for emails. The first is that they are primarily graphical (GUIs) and are not languages (DSLs). The advantage of DSLs for this problem is that they are more portable (e.g., one person from HR can send a text file with the email generating "code" over to another without having to manually transfer settings and populate fields on a graphical interface on the other person's computer). Another is that languages are more powerful, which allows for constructs like basic control flow (such as conditionals) and loops. Our language could even be used by GUI developers as a sort of intermediate representation of what is being automated. We hope that our language will be able to cover a greater number of use cases beyond "find and replace," which existing solutions provide. We do aim to make our DSL less complex than a GPL so that it is easier for non-programmers such as HR teams and marketers to define email templates, however. The output of our DSL will be a set of plaintext files (e.g., personalized emails for each recipient on a list defined by the language user).

Create example inputs, both valid and invalid.
--------------------------------
<b>Key Questions:</b> What is the expected output for some examples of valid input? How will you detect and report those that are invalid?

<b>Note:</b> These examples are outdated due to the changes made to the grammar.

<u>Valid Comment Input:</u><br>
``` DSL
((comments are in parenthesis because this is intuitive for non-technical staff))
```

<u>Invalid Comment Inputs:</u><br>
``` DSL
(single parentheses do not work because they might be used in the mail body)
// these comments are what programmers are used to, not hr
/* same with these */
# and these
```

<u>Valid List Declaration:</u><br>
``` DSL
((everything is a list of ASCII strings, defined as name: "string1", "string2", "string3"))
((strings in a list can be paired with an <email@domain.coml>))
Subject: "New Start Date For New Employees" ((defining subject line))
Sender: "Company HR" <hr@company.com> ((defining sender))
Recipient: "John" <John@gmail.com>, "Joe" <Joe@gmail.com>, "James" <James@gmail.com> ((defining list of recipients))
```

<u>Invalid List Declaration:</u><br>
``` DSL
subject = "New Start Date" ((this would be GPL-like syntax, not suitable for DSL))
subject: name <email>  ((invalid email syntax))
```

<u>Valid Mail Body Declaration:</u><br>
``` DSL
((defining body for mail, comments do not apply inside body))
Begin Body MailBody (X): ((X is a parameter))
Dear {Recipient (X)}, ((Xth string in recipient list, string over email by default))

Your new official start date is 7/12/2025, Please contact us if you have any questions.

Sincerely,
{Sender} ((places the first string of the list sender here))
{Sender (Email)} ((places the email of the first element in sender here, email is a keyword))
End Body
```

<u>Invalid Mail Body Declaration:</u><br>
``` DSL
MailBody: ((this syntax for lists, does not work with multiple lines))
Dear X,
Hope you are doing well. Your role will be {title}. (({title} has not been defined previously))
Sincerely, Joe
```

<u>Valid Email Generation:</u><br>
``` DSL
Begin Loop with X from 1 to Recipient (Length): ((index X from 1 to length of recipients list))
Generate using MailBody (X) as Body ((generates emails for each recipient in the list))
Print (done with {Recipient (X)}) ((print statement))
End Loop
```

<u>Invalid Email Generation:</u><br>
``` DSL
Generate using MailBody as Body for each Recipient (X) ((this is too informal))
```

<u>Examples of Invalid Semantics:</u><br>
``` DSL
Begin Body Example:
{Recipient (100)} ((out of bounds index))
{ifwhbehjf} ((identifier not defined previously))
{Subject (Email)} ((subject does not have an associated email))
End Body
```

Define functionality.
--------------------------------
<b>Key Questions:</b> How is the output determined for a given input? In other words, how will you demonstrate that your language is working?

We will run our input through a lexer, parser, and then translator in order to generate the output. The lexer will turn the input into tokens, and those tokens will be parsed using ANTLR according to the context-free grammar we define for our language. If the the input as conforms to our language's grammar (examples above), then the translator will attempt to generate output. Otherwise, the input will be rejected with a syntax error (parsing ANTLR is one way in which incorrect outputs will be identified). Then, our translator will go through the parse tree generated by the parser, terminating with a runtime error if there is an undefined identifier, invalid parameter, etc (this is the second way in which incorrect outputs will be identified). If everything is correct, then it will translate the input into a set of plaintext files containing the emails (specifically, the target language is English). At this point, the input will have passed all the steps and be considered "working." Examples of what our translator should be capable of doing include determining what identifiers refer to, resolving if statements, and iterating through loops. 

Talk with the professor, and get approval.
--------------------------------
Done, see meeting dates section.


Include meeting dates and approval dates in readme.
--------------------------------
Done, see meeting dates section.


P01: Grammar
======================
Create a grammar for the DSL.
--------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CFG
program -> statement*

statement -> (' ' | '\n')* ( declaration
                     | conditional | loop
                     | genStmt | printStmt ) (' ' | '\n')*

declaration -> numDec | listDec | bodyDec

numDec -> (ID " = " expression '\n') | numOp

numOp -> ("Increment " ID) | ("Decrement " ID)

listDec -> ID ": " possibleStr (", " possibleStr)* '\n'

bodyDec -> "Begin Body " ID ":\n"
           content '\n'
           "End Body\n"

conditional -> "Begin Check, If [" expression "]:\n"
               statement*?
               "End Check\n"

loop -> "Begin Loop, " ( "Repeat [" expression "] Times"
                     | "While [" expression "]:" ) '\n'
        statement*?
        "End Loop\n"

genStmt -> "Generate " ID '\n'

printStmt -> "Print " (possibleStr | expression) '\n'

expression -> ( possibleNum (OP possibleNum)* )
              | (possibleStr " In " ID)

possibleNum -> NUM | ID | indexedID

possibleStr -> string | ID | indexedID

string -> '\"' CHAR*? '\"'

content -> ("{" (ID | indexedID) "}" | CHAR)*?

indexedID -> ID ' (' (expression | '\"' "Count" '\"') ')'

ID -> (a-z | A-Z) (a-z | A-Z | 0-9)*
NUM -> (0-9)+
OP -> ' ' ('+' | '-' | '*' | '/' | 'Mod'
         | 'Is' | ">=" | "<=" | '>' | '<'
         | 'And' | 'Or' | 'Not') ' '
CHAR -> [any character]

skip COMMENT -> "/*" CHAR*? "*/"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Test example inputs against grammar.
--------------------------------
<b>Key Question:</b> Do the valid inputs work and invalid inputs not?<br>

Our grammar changed significantly (see the next subsection), so we designed new inputs and verified that the valid ones work and the invalid ones don't. The three example programs contain various "statements" (which are valid as standalone inputs) to achieve specific functionality, while the examples of syntactically invalid statements fail to conform to the grammar. The semantically invalid statements do pass the grammar, but would lead to runtime errors during our translation step. For example program 1 only (due to how long it takes), I have attached a hand-drawn parse tree showing that it works (the other programs were verified by looking at the grammar).

<b>Hand-Drawn Parse Tree (Slightly Outdated):</b><br>
![](files/p01_parsetree.jpg)

<b>Example Program 1 - Personalized Mails w/ Loop:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
recipient: "John", "Joe", "James", "Jessie"

Begin Body mail:
Dear {recipient (i)},
This is an email, personalized to you.
End Body

i = 1
Begin Loop, Repeat [recipient ("Count")] Times:
    Generate mail
    Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Example Program 2 - Shift Assignment w/ Modulos:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
recipient: "John", "Joe", "James", "Jessie"
shift: "day", "night"

Begin Body mail:
Dear {recipient (i)},
Come in for the {shift (i Mod 2 + 1)} shift tomorrow.
End Body

i = 1
Begin Loop, Repeat [recipient ("Count")] Times:
    Generate mail
    Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Example Program 3 - Task Assignment w/ Nested Loops:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
recipient: "John", "Joe", "James", "Jessie"
project: "website", "desktop app"
platform: "Mac", "Windows"

Begin Body mail:
Dear {recipient (c)},
Your task is to create a {project (i)} for {platform (j)}.
End Body

c = 1
i = 1
Begin Loop, Repeat [project ("Count")] Times:
    j = 1
    Begin Loop, Repeat [platform ("Count")] Times:
        Generate mail
        Increment c
        Increment j
    End Loop
    Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Examples of Syntactically Invalid Inputs (Rejected by Parser):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* syntax from other languages */
if (i < 0) {
    i = 0;
}
print(i)

/* capitalization errors */
print i
PRINT i

/* issues with closing statements */
Begin Body invalid1:
*/
End Loop
Begin Check, If i = 0

/* ignoring whitespace conventions */
BeginBody invalid2: testing 123 EndBody

/* not using curly brackets when indexing */
Print recipients (0)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Examples of Semantically Invalid Inputs (Not Rejected By Parser):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* undefined variable */
Increment var

/* out of bonds index */
Print {recipients (100)}

/* division by 0 */
i = 1 / 0

/* boolean algebra with whole numbers */
i = 1 And 2

/* incorrect type of identifier */
string: "hello"
recipients(string)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Do you have to make corrections or changes?
--------------------------------
Numerous changes were made to the grammar for various reasons, such as for removing ambiguity in parsing/writing inputs. Several features were added for increased usability, and several were removed due to introducing complications (+ minor syntax changes). 

Here the changes that we've deemed notable:
* Integers and expressions have been added because they are extremely useful for many automation tasks. Integer declaration is done by assigning an identifier to an initial value with '=' (type is inferred). They can be incremented and decremented using "Increment" and "Decrement" (they are unary operators that go before the identifier). Expressions support multiple binary operations in sequence from left to right including arithmetic, logic, and comparisons (parenthesis are not supported to discourage convoluted equations and reduce translation complexity, 0 and 1 are treated as booleans for logic operators and comparison results). 
* Nested statements, including nested loops, are now possible. As seen in the 3rd example program, Iterating over all combinations of things in lists is a common task that are language is not capable of. Nested conditionals are also supported; a result of this is that our language is very powerful, capable of some GPL tasks. 
* Bodies no longer have parameters. To achieve the same functionality, indexing will be evaluated at runtime, so declaring a variable with the former parameter's name and modifying that variable will result in the same behavior (our examples all show this behavior for personalized recipient names). 
* There is no longer whitespace, as ignoring spaces and new lines would lead to poorly formatted mail bodies. Enforcing whitespace rules also allows for neater code, which is something that we want to "encourage."
* ((This is no longer a comment)) /* This is. It looks much better, it's not actually that difficult for non-programmers to learn, and most importantly, people won't confuse it with mathematical notation and try to use it in expressions. */
* Pairing strings with emails (and having a special email type) is deprecated. Emails can simply be stored as strings in a separate list, so pairing adds too much translation complexity for no good reason. 


P02: Parser
======================
TBD

P03: Prototype
======================
TBD

P04: Release Candidate
======================
TBD

P05: Final
======================
TBD

<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>