**CS59 DSL Project**

Author
=============
<div class="noheader firstcol">
                  |             
------------------|-------------
Team Members      | Owen Chen & Cody Zang
Computer + OS     | Windows 11 & macOS
Time to Complete  | ~8.5 (×2) hours so far
Additional Help   | Consulting w/ Prof. & TAs
</div>

Disclaimer
================
This readme is more of a documentation of the development process rather than the most recent version of the DSL. Many of the grammar rules and examples outlined in the older sections are outdated and should be viewed as such. 

Meeting Dates
================
* 7/12/2025, 3-5pm: initial meeting to complete P00
* 7/15/2025, 3:30-4pm: meeting with professor, recieved approval
* 7/23/2025, 5:00-8:30pm: meeting to design and test grammar
* 7/30/2025, 2:15-4:45pm: meeting to develop ANTLR parser and test it
* Future dates TBD...

P00: Selection
================
Define the domain.
--------------------------------
Our domain is email automation. Oftentimes in professional settings, email templates and similar tools are used in order to save time communicating. Key considerations in this domain are ease of use/learning (because non-technical staff will be using these tools) and output reliability/correctness (as these emails will be going to clients and other staff). There do exist tools for this sort of task, but they are not languages (more on that later, see below), so our approach the problem seems not to have been done before. 

Define the problem.
--------------------------------
<b>Key Question:</b> What is the purpose of the language?

There are several key issues with existing automation tools for emails. The first is that they are primarily graphical (GUIs) and are not languages (DSLs). The advantage of DSLs for this problem is that they are more portable (e.g., one person from HR can send a text file with the email generating "code" over to another without having to manually transfer settings and populate fields on a graphical interface on the other person's computer). Another is that languages are more powerful, which allows for constructs like basic control flow (such as conditionals) and loops. Our language could even be used by GUI developers as a sort of intermediate representation of what is being automated. We hope that our language will be able to cover a greater number of use cases beyond "find and replace," which existing solutions provide. We do aim to make our DSL less complex than a GPL so that it is easier for non-programmers such as HR teams and marketers to define email templates, however. The output of our DSL will be a set of plaintext files (e.g., personalized emails for each recipient on a list defined by the language user).

Create example inputs, both valid and invalid.
--------------------------------
<b>Key Questions:</b> What is the expected output for some examples of valid input? How will you detect and report those that are invalid?

<u>Valid Comment Input:</u><br>
``` DSL
((comments are in parenthesis because this is intuitive for non-technical staff))
```

<u>Invalid Comment Inputs:</u><br>
``` DSL
(single parentheses do not work because they might be used in the mail body)
// these comments are what programmers are used to, not hr
/* same with these */
# and these
```

<u>Valid List Declaration:</u><br>
``` DSL
((everything is a list of ASCII strings, defined as name: "string1", "string2", "string3"))
((strings in a list can be paired with an <email@domain.coml>))
Subject: "New Start Date For New Employees" ((defining subject line))
Sender: "Company HR" <hr@company.com> ((defining sender))
Recipient: "John" <John@gmail.com>, "Joe" <Joe@gmail.com>, "James" <James@gmail.com> ((defining list of recipients))
```

<u>Invalid List Declaration:</u><br>
``` DSL
subject = "New Start Date" ((this would be GPL-like syntax, not suitable for DSL))
subject: name <email>  ((invalid email syntax))
```

<u>Valid Mail Body Declaration:</u><br>
``` DSL
((defining body for mail, comments do not apply inside body))
Begin Body MailBody (X): ((X is a parameter))
Dear {Recipient (X)}, ((Xth string in recipient list, string over email by default))

Your new official start date is 7/12/2025, Please contact us if you have any questions.

Sincerely,
{Sender} ((places the first string of the list sender here))
{Sender (Email)} ((places the email of the first element in sender here, email is a keyword))
End Body
```

<u>Invalid Mail Body Declaration:</u><br>
``` DSL
MailBody: ((this syntax for lists, does not work with multiple lines))
Dear X,
Hope you are doing well. Your role will be {title}. (({title} has not been defined previously))
Sincerely, Joe
```

<u>Valid Email Generation:</u><br>
``` DSL
Begin Loop with X from 1 to Recipient (Length): ((index X from 1 to length of recipients list))
Generate using MailBody (X) as Body ((generates emails for each recipient in the list))
Print (done with {Recipient (X)}) ((print statement))
End Loop
```

<u>Invalid Email Generation:</u><br>
``` DSL
Generate using MailBody as Body for each Recipient (X) ((this is too informal))
```

<u>Examples of Invalid Semantics:</u><br>
``` DSL
Begin Body Example:
{Recipient (100)} ((out of bounds index))
{ifwhbehjf} ((identifier not defined previously))
{Subject (Email)} ((subject does not have an associated email))
End Body
```

Define functionality.
--------------------------------
<b>Key Questions:</b> How is the output determined for a given input? In other words, how will you demonstrate that your language is working?

We will run our input through a lexer, parser, and then translator in order to generate the output. The lexer will turn the input into tokens, and those tokens will be parsed using ANTLR according to the context-free grammar we define for our language. If the the input as conforms to our language's grammar (examples above), then the translator will attempt to generate output. Otherwise, the input will be rejected with a syntax error (parsing ANTLR is one way in which incorrect outputs will be identified). Then, our translator will go through the parse tree generated by the parser, terminating with a runtime error if there is an undefined identifier, invalid parameter, etc (this is the second way in which incorrect outputs will be identified). If everything is correct, then it will translate the input into a set of plaintext files containing the emails (specifically, the target language is English). At this point, the input will have passed all the steps and be considered "working." Examples of what our translator should be capable of doing include determining what identifiers refer to, resolving if statements, and iterating through loops. 

Talk with the professor, and get approval.
--------------------------------
Done, see meeting dates section.

Include meeting dates and approval dates in readme.
--------------------------------
Done, see meeting dates section.

P01: Grammar
======================
Create a grammar for the DSL.
--------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Pseudocode
program -> statement*

statement -> (‘\n’)* ( declaration
                     | conditional | loop
                     | genStmt | printStmt ) (‘\n’)*

declaration -> numDec | listDec | bodyDec

numDec -> (ID “ = ” expression ‘\n’) | numOp

numOp -> (“Increment ” ID) | (“Decrement ” ID)

listDec -> ID “: ” possibleStr (“, ” possibleStr)* ‘\n’

bodyDec -> “Begin Body ” ID “:\n”
           content ‘\n’
           “End Body\n”

conditional -> “Begin Check ” expression “:\n”
               statement*
               “End Check\n”

loop -> “Begin Loop ” ( “For ” expression “ Times”
                     | “While ” expression ) “:\n”
        statement*
        “End Loop\n”

genStmt -> “Generate ” ID ‘\n’

printStmt -> “Print ” (possibleStr | expression) ‘\n’

expression -> ( possibleNum (OP possibleNum)* )
              | (possibleStr “ In ” ID)

indexedID -> “{ “ ID ‘ (’ (expression | “Count”) ‘)’ “ }”

possibleNum -> NUM | ID | indexedID

possibleStr -> string | ID | indexedID

string -> ‘\“’ CHAR* ‘\”’

content -> (indexedID | CHAR)*

ID -> (a-z | A-Z) (a-z | A-Z | 0-9)*
NUM -> (0-9)+
OP -> ‘ ’ (‘+’ | ‘-’ | ‘*’ | ‘/’ | ‘Mod’
         | ‘Is’ | “>=” | “<=” | ‘>’ | ‘<’
         | ‘And’ | ‘Or’ | ‘Not’) ‘ ’
CHAR -> any ASCII character

skip comment -> “/*” [any character]* “*/”
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Test example inputs against grammar.
--------------------------------
<b>Key Question:</b> Do the valid inputs work and invalid inputs not?<br>

Our grammar changed significantly (see the next subsection), so we designed new inputs and verified that the valid ones work and the invalid ones don't. The three example programs contain various "statements" (which are valid as standalone inputs) to achieve specific functionality, while the examples of syntactically invalid statements fail to conform to the grammar. The semantically invalid statements do pass the grammar, but would lead to runtime errors during our translation step. For example program 1 only (due to how long it takes), I have attached a hand-drawn parse tree showing that it works (the other programs were verified by looking at the grammar).

<b>Hand-Drawn Parse Tree for Example 1:</b><br>
![](files/p01_parsetree.jpg)

<b>Example Program 1 - Personalized Mails w/ Loop:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
recipient: “John”, "Joe", “James”, “Jessie”

Begin Body mail:
Dear { recipient (i) },
This is an email, personalized to you.
End Body

i = 1
Begin Loop For { recipient (Count) } Times:
Generate mail
Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Example Program 2 - Shift Assignment w/ Modulos:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
recipient: “John”, "Joe", “James”, “Jessie”
shift: “day”, “night”

Begin Body mail:
Dear { recipient (i) },
Come in for the { shift (i Mod 2 + 1) } shift tomorrow.
End Body

i = 1
Begin Loop For { recipient (Count) } Times:
Generate mail
Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Example Program 3 - Task Assignment w/ Nested Loops:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
recipient: “John”, "Joe", “James”, “Jessie”
project: “website”, “desktop app”
platform: “Mac”, “Windows”

Begin Body mail:
Dear { recipient (c) },
Your task is to create a { project (i) } for { platform (j) }.
End Body

c = 1
i = 1
Begin Loop For { project (Count) } Times:
j = 1
Begin Loop For { platform (Count) } Times:
Generate mail
Increment c
Increment j
End Loop
Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Examples of Syntactically Invalid Inputs (Rejected by Parser):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* syntax from other languages */
if (i < 0) {
    i = 0;
}
print(i)

/* capitalization errors*/
print i
PRINT i

/* issues with closing statements */
Begin Body invalid1:
*/
End Loop
Begin Check i = 0

/* ignoring whitespace conventions */
BeginBody invalid2: testing 123 EndBody

/* not using curly brackets when indexing */
Print recipients (0)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Examples of Semantically Invalid Inputs (Not Rejected By Parser):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* undefined variable */
Increment var

/* out of bonds index */
Print { recipients (100) }

/* division by 0 */
i = 1 / 0

/* boolean algebra with whole numbers */
i = 1 And 2

/* incorrect type of identifier */
string: “hello”
recipients(string)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Do you have to make corrections or changes?
--------------------------------
Numerous changes were made to the grammar for various reasons, such as for removing ambiguity in parsing/writing inputs. Several features were added for increased usability, and several were removed due to introducing complications (+ minor syntax changes). 

Here the changes that we've deemed notable:
* Integers and expressions have been added because they are extremely useful for many automation tasks. Integer declaration is done by assigning an identifier to an initial value with ‘=’ (type is inferred). They can be incremented and decremented using "Increment" and "Decrement" (they are unary operators that go before the identifier). Expressions support multiple binary operations in sequence from left to right including arithmetic, logic, and comparisons (parenthesis are not supported to discourage convoluted equations and reduce translation complexity, 0 and 1 are treated as booleans for logic operators and comparison results). 
* Nested statements, including nested loops, are now possible. As seen in the 3rd example program, Iterating over all combinations of things in lists is a common task that are language is not capable of. Nested conditionals are also supported; a result of this is that our language is very powerful, capable of some GPL tasks. 
* Bodies no longer have parameters. To achieve the same functionality, indexing will be evaluated at runtime, so declaring a variable with the former parameter's name and modifying that variable will result in the same behavior (our examples all show this behavior for personalized recipient names). 
* There is no longer whitespace, as ignoring spaces and new lines would lead to poorly formatted mail bodies. Enforcing whitespace rules also allows for neater code, which is something that we want to “encourage.”
* ((This is no longer a comment)) /* This is. It looks much better, it's not actually that difficult for non-programmers to learn, and most importantly, people won’t confuse it with mathematical notation and try to use it in expressions. */
* Pairing strings with emails (and having a special email type) is deprecated. Emails can simply be stored as strings in a separate list, so pairing adds too much translation complexity for no good reason. 

P02: Parser
======================
Use ANTLR to generate a parser for the language.
--------------------------------
<b>ANTLR Grammar:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ANTLR
grammar DSL;

parse : statement* EOF;

statement : (' ' | ENDL)* ( declaration
                          | conditional | loop
                          | genStmt | printStmt ) '.' ENDL*;

declaration : numDec | listDec | templateDec;

numDec : ( (ID ' = ' expression) | numOp );

numOp : ('Increment ' ID) | ('Decrement ' ID);

listDec : ID ': ' possibleStr (', ' possibleStr)*;

templateDec : 'Begin Template ' ID ':' ENDL*
          (' ' | ENDL)* content ENDL* (' ' | ENDL)*
          'End Template';

conditional : 'Begin Check, If [' expression ']:' ENDL*
              statement*? (' ' | ENDL)*
              'End Check';

loop : 'Begin Loop, ' ( 'Repeat [' expression '] Times'
                      | 'While [' expression ']' ) ':' ENDL*
        statement*? (' ' | ENDL)*
        'End Loop';
        
genStmt : 'Generate ' ID;

printStmt : 'Print ' (possibleStr | expression);

expression : ( possibleNum (OP possibleNum)* )
           | ( possibleStr ' In ' ID );

possibleNum : NUM | ID | indexedID;

possibleStr : STR | ID | indexedID;

content : (substitution | CNT)*?;

substitution : (ID | indexedID);

indexedID : ID ' (' (expression | ('"Count"' | '"Random"')) ')';

CNT : ('`' .*? '{')
    | ('}' .*? '{')
    | ('}' .*? '`')
    | ('`' .*? '`');

ID : [a-zA-Z] [a-zA-Z0-9]*;
NUM : [0-9]+;
OP : ' ' ('+' | '-' | '*' | '/' | 'Mod'
         | 'Is' | '>=' | '<=' | '>' | '<'
         | 'And' | 'Or' | 'Not') ' ';
STR : '"' .*? '"';
ENDL : ('\r')? '\n';

COMMENT : '/*' .*? '*/' -> skip;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The above grammar is a translated version of the P001 grammar, with various changes to make it compatible with ANTLR and resolve parsing ambiguities. 

Test the parser for agreement with the design.
--------------------------------
<b>Testing Code:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Java
import org.antlr.v4.runtime.*;
import java.io.File;
import java.io.FileInputStream;

public class Test {
    public static void parseHelper(String file) throws Exception {
        FileInputStream in = new FileInputStream(file);
        CharStream input = CharStreams.fromStream(in);
        DSLLexer lexer  = new DSLLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        DSLParser parser = new DSLParser(tokens);
        parser.parse();
    }

    public static void main(String[] args) throws Exception {
        File validDir = new File("tests/valid/");
        File[] validFiles = validDir.listFiles();
        if (validFiles != null) {
            for (File file : validFiles) {
                System.out.println("Testing File (Valid Input): " + file.getName());
                parseHelper(file.getPath());
                Thread.sleep(10);
                System.out.println("Done: Expect No Error.\n");
            }
        }

        File invalidDir = new File("tests/invalid/");
        File[] invalidFiles = invalidDir.listFiles();
        if (invalidFiles != null) {
            for (File file : invalidFiles) {
                System.out.println("Testing File (Invalid Input): " + file.getPath());
                parseHelper(file.getPath());
                Thread.sleep(10);
                System.out.println("Done: Expect Error Above.\n");
            }
        }
    };
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Screenshot (Test Results pt. 1):</b><br>
![](images/p02_testresults1.png)

<b>Screenshot (Test Results pt. 2):</b><br>
![](images/p02_testresults2.png)

<b>Screenshot (Test Results pt. 3):</b><br>
![](images/p02_testresults2.png)

<b>Screenshot (Parse Tree for Program 1):</b><br>
![](images/p02_parsetree1.png)

<b>Screenshot (Parse Tree for Program 2):</b><br>
![](images/p02_parsetree2.png)

<b>Screenshot (Parse Tree for Program 3):</b><br>
![](images/p02_parsetree3.png)

After some debugging, the parser now accepts and rejects inputs as expected. See below for information on the exact tests.

Create more valid and invalid inputs that fully test your language design.
--------------------------------
Because of grammar changes, the tests created for the last milestone's grammar no longer work. We had to create new tests and modify old tests to test the ANTLR parser. We ended up with 3 valid input programs (which contain multiple statements that would work as standalone examples), 1 valid input example of a language feature, and 8 invalid input examples. See below for the exact tests (the exact behavior being tested in described in the comments). They are located in the "tests" folder of the IntelliJ project. 

<b>Valid Input: defaultidx.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: un-indexed list ID defaults to first element */
hi: "Hello World".
Print hi.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Valid Input: program1.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: personalized recipients */

recipient: "John", "Joe", "James", "Jessie".

Begin Template mail:
`Dear {recipient (i)},
This is an email, personalized to you.`
End Template.

i = 1.
Begin Loop, Repeat [recipient ("Count")] Times:
    Generate mail.
    Increment i.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Valid Input: program2.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: shift assignment */

recipient: "John", "Joe", "James", "Jessie".
shift: "day", "night".

Begin Template mail:
`Dear {recipient (i)},
Come in for the {shift (i Mod 2 + 1)} shift tomorrow.`
End Template.

i = 1.
Begin Loop, Repeat [recipient ("Count")] Times:
    Generate mail.
    Increment i.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Valid Input: program3.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: task assignment */

recipient: "John", "Joe", "James", "Jessie".
project: "website", "desktop app".
platform: "Mac", "Windows".

Begin Template mail:
`Dear {recipient (c)},
Your task is to create a {project (i)} for {platform (j)}.`
End Template.

c = 1.
i = 1.
Begin Loop, Repeat [project ("Count")] Times:
    j = 1.
    Begin Loop, Repeat [platform ("Count")] Times:
        Generate mail.
        Increment c.
        Increment j.
    End Loop.
    Increment i.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: allcapserror.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid due to case mismatch */
PRINT "Hello World".
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: cstyleifstmt.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: if statement using c style syntax */
if (i < 0) {
    i = 0;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: exprparens.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: parenthesis not supported in expressions */
num = 32487 + (87239 / 1374).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: invalidtype.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: declaring list of numbers */
numbers: 1, 2, 3, 4.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: noloopend.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: loop not terminated */
Begin Loop, Repeat [recipient ("Count")] Times:
    Generate mail.
    Increment i.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: notenclosed.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: content not enclosed with backticks */
Begin Template mail:
Dear {recipient (i)},
This is an email, personalized to you.
End Template.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: noterminate.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: statements not terminated with periods */
Begin Loop, Repeat [recipient ("Count")] Times:
    Generate mail
    Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: printparens.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: print enclosed in parentheses */
Print("Hello").
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

P03: Prototype
======================
Generate a translator based on the desired functionality and examples.
--------------------------------
<b>Updated ANTLR Grammar:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ANTLR
TBD
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TBD

Test the translator against your trivial inputs (valid and invalid).
--------------------------------
TBD

Begin testing against non-trivial inputs.
--------------------------------
TBD

P04: Release Candidate
======================
TBD

P05: Final
======================
TBD

<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>