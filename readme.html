**MASL Documentation**

Contributors
=============
<div class="noheader firstcol">
                   |             
-------------------|-------------
Primary Authors    | Owen Chen and Cody Zang 
Additional Helpers | The Professor and TAs of COSC 59
External Resources | ANTLR, Java, and Python documentation

</div>

Introduction
================
MASL (Mail Automation Scripting Language) is a domain-specific language designed to help automate the process of mass emailing. MASL supports the creation of email templates, the generation of personalized emails based on those templates, and provides tooling to send those emails en masse. It targets all platforms that Java (the host language) runs on. As opposed to other tools for this purpose, MASL is purely text based and does not have a GUI. As a result, MASL is more powerful (it is capable of doing any automation task that a computer program can do because it is Turing-complete) and more portable (automation scripts can be easily transferred between team members, unlike most GUI configurations). The main disadvantage of a language-based approach is that it can be less intuitive for nontechnical staff, which we attempted to offset by making MASL syntax as readable as possible for non-programmers, and the interpretation as generous as possible. 

Getting Started
================
Setup Details
--------------------------------
The "release" folder provides everything that is needed to get started. Provided that Java is installed, MASL scripts can be run using the following command: 
``` CMD
java -jar Interpreter.jar path/to/script.masl
```

Python should also be installed to use "dir2email.py" (a tool to send the output of a MASL script as a series of emails). 

Example Script
--------------------------------
The example script "task_assign.masl" is provided in the "inputs" folder. Its contents are repeated below for convenience:
``` MASL
/* task assignment */

recipient: "John", "Joe", "James", "Jessie".
product: "website", "desktop app".
platform: "Mac", "Windows".

Randomize recipient.

Begin Template task_mail:
`Dear {recipient (c)},

Your task is to create a {product (i)} for {platform (j)}.

Sincerely,
Jeffery`
End Template.

c = 1.

Begin Loop, Incrementing i, Repeat 2 Times:
    Begin Loop, Incrementing j, Repeat 2 Times:
        Generate task_mail.
        Increment c.
    End Loop.
End Loop.
```

This script solves the problem of task assignment. The hypothetical company that would use this script has multiple different "products" that need to be developed for each of its target "platforms". The script does this by randomly assigning the four combinations of tasks to four employees, and then generating a personalized email that can be sent to each employee in order to notify them of their task. 

To run this, one would use the command "java -jar Interpreter.jar inputs/task_assign.masl". The generated emails will be placed in the "out" folder as text files. To send these out as emails, one would fill out the "login.txt" file with the company's Gmail address and app password (https://support.google.com/mail/answer/185833?hl=en). Then, they would run "dir2email.py", and once prompted by the program, would specify the directory containing the emails, the aforementioned login file, the subject lines of each email, and finally the email addresses of the recipients. 

Script Writing
======================
This section provides a basic introduction to script writing with MASL, and should be studied extensively before attempting to use the language. After reading this, a person will have the knowledge required to complete basic mail automation tasks such as generating personalized emails. 

Comments
--------------------------------
When writing scripts, it is good practice to annotate parts to explain their function. This can be achieved through comments, which are ignored when the script is being run but are visible when editing the script. Here is an example: 
``` MASL
/* anything in between these symbols is ignored */
```

String Lists
--------------------------------
In MASL, variables are a fundamental construct that allow for the storage of data. The first type of variable that one will most likely encounter in a MASL script is a list. Here is what a list declaration looks like:
``` MASL
listId: "string 1", "string 2", "...". /* quotes enclose string content */
```

This line stores the strings (sequences of characters) "string 1", "string 2", and "..." under the identifier listId. The identifier name, content of the strings, and the number of strings stored can be changed as needed. The syntactic components (e.g., the colon after the identifier, the comma between list elements, and the period at the end) should not be changed, however, as they are required for the MASL interpreter to understand what is being expressed. This is a general rule that should be followed when writing scripts. 

Strings within lists can be accessed and modified, provided that the declaration of the list happens earlier in the script:
``` MASL
Write listId. /* outputs "string 1" to console */
Write listId (1). /* also outputs "string 1" */
Write listId (2). /* outputs "string 2" */
Write listId (3). /* outputs "..." */

Set listId (3) To "string 3". /* changes "..." to "string 3" */
Write listId (3). /* outputs "string 3" */
Randomize listId. /* shuffles the contents of the list randomly */

listId2: listId (1), listId (2), listId (3). /* creates copy of listId */
```

Note that referring to identifiers that have not been declared (in an attempt to modify or access them) will result in an error in most cases (the most notable exception is that "Read listId", which is used for taking in user input, will create listId if it is not already declared; the "Incrementing numId" clause of a loop will also create numId in similar fashion). 

Numbers
--------------------------------
The second type of variable is "number", used to store integer values:
``` MASL
numId = 10. /* this is also how numbers are modified */
negNum = -1. /* numbers can also be negative */
```


Numbers are interesting because they can be used in math expressions. For example:
``` MASL
Write numId + 5. /* outputs 15 */
```

Expressions in MASL support the following operators: "+", "-", "*" (multiply), "/" (divide) "Mod" (modulus, which gets the remainder of a division operation), "Is", "Isn't", ">=" (greater than or equals), "&lt=" (less than or equals), ">", "&lt", "And" (logical and), and "Or" (logical or). Note that logical operators only work on 0 (false) and 1 (true). These are also the values returned by operations such as "Is" and ">". Note that an expression can contain multiple operators, but have no precedence (i.e., no order of operations; they are evaluated from left to right, and parentheses are not supported). For example:
``` MASL
Write 1 + 2 * 3. /* outputs 9 and not 7 */
```

In addition to setting the value of a number variable directly with "=", it is also possible to change them by a value:
``` MASL
Increment negNum. /* negNum increases by 1 to 0 */
Decrement negNum By 10. /* negNum is now -10 */
```

At this point, it should be noted that case sensitivity is important in MASL. For example, "Is" is a valid operator but "is" is not. Similarly, "numId" (which ends with a lowercase "d") was previously defined as 10, but "numID" (which ends with a capital "D") is undefined. 

Templates
--------------------------------
Templates can make use of the aforementioned variables to create personalized emails. Here is a template declaration:
``` MASL
Begin Template templateId:
`Dear {recipient (i)},

This is an email, personalized to you.

Sincerely,
Jeffery`
End Template.
```

When the list variable "recipient" and the number variable "i" are defined, "{recipient (i)}" will be substituted with the ith element of the "recipient" list. Once all variables used in the template are defined, a mail can be generated from it:
``` MASL
i = 1.
recipient: "Joe".
Generate templateId. /* places the generated mail in the "out" directory */ 
```

Checks/Loops
--------------------------------
MASL supports the conditional expression of statements via the check construct:
``` MASL
Begin Check, If condition1 And condition2:
	Write "both true". /* this only outputs "both true" if both conditions are true */
End Check. /* note the period here */
```

MASL also supports the execution of a statement "while" a condition holds:
``` MASL
i = 1.
Begin Loop, While i &lt= 3: /* stop when this is false */
	Write i. /* outputs 1, then 2, then 3 */
	Increment i. /* i grows each iteration */
End Loop.
```

Increment statements that happen at the end of the loop can be simplified:
``` MASL
i = 1.
Begin Loop, Incrementing i, While i &lt= 3: /* i is 1, then 2, then 3 */
	Write i. /* same output as before */
End Loop.
```

This can also be refactored into a "repeat" loop:
``` MASL
i = 1.
Begin Loop, Incrementing i, Repeat 3 Times:
	Write i. /* same output as before */
End Loop.
```

Now it becomes possible to understand the example script provided earlier:
``` MASL
/* defining lists */
recipient: "John", "Joe", "James", "Jessie".
product: "website", "desktop app".
platform: "Mac", "Windows".

/* randomizing recipient order */
Randomize recipient.

/* creating a template */
Begin Template task_mail:
`Dear {recipient (c)}, /* match name of recipient */

Your task is to create a {product (i)} for {platform (j)}. /* assign task */

Sincerely,
Jeffery`
End Template.

c = 1. /* c will track the recipient number */

/* the nested loop will go over each combination of i and j */
/* this is the same as each combination of product and platform */
Begin Loop, Incrementing i, Repeat 2 Times:
    Begin Loop, Incrementing j, Repeat 2 Times:
        Generate task_mail.
        Increment c. /* next recipient */
    End Loop.
End Loop.
```

Debugging
--------------------------------
MASL has robust error handling, and its messages are written to be as intuitive as possible. When debugging, keep in mind that there are two types of errors: syntax and runtime errors. Syntax errors identify a specific line where parsing failed, and indicate that the structure of the script does not match what is expected. Runtime errors happen after parsing and are caused when the interpreter is unable to reasonably execute a statement or operation (e.g., division by 0). Encountering an error means the script most likely has to be corrected and sometimes even rewritten. 

Advanced Usage
================
For most MASL users doing ordinary mail automation tasks, this section can be safely ignored. For technical users seeking to use MASL as more of a GPL (General Purpose Language), this section will be helpful.

Grammar
--------------------------------
In ANTLR syntax, here is the grammar of the language:

``` ANTLR
grammar DSL;

start : statement* EOF;

statement : ( declaration
            | operation
            | conditional | loop
            | genStmt | ioStmt ) '.';

declaration : numDec | listDec | templateDec;

numDec : ID '=' expression;

listDec : ID ':' possibleStr (',' possibleStr)*;

operation : numOp | listOp;

numOp : incOp | decOp;

incOp : 'Increment ' ID (' By ' expression)?;

decOp : 'Decrement ' ID (' By ' expression)?;

listOp : setOp | randOp;

setOp : 'Set ' ID ('(' expression ')')? ' To ' possibleStr;

randOp : 'Randomize ' ID;

templateDec : 'Begin Template ' ID ':'
              content
              'End Template';

conditional : 'Begin Check,'
              'If ' expression ':'
              statement*?
              'End Check';

loop : repeatLoop | whileLoop;

repeatLoop : 'Begin Loop,'
             ('Incrementing ' ID ',')?
             'Repeat ' expression ' Times:'
             statement*?
             'End Loop';

whileLoop : 'Begin Loop,'
            ('Incrementing ' ID ',')?
            'While ' expression ':'
            statement*?
            'End Loop';

genStmt : 'Generate ' ID;

ioStmt : readStmt | writeStmt;

readStmt : 'Read ' ID;

writeStmt : 'Write ' (possibleStr | expression);

expression : possibleNum (OP possibleNum)*;

possibleNum : NUM | ID | indexedID;

possibleStr : STR | ID | indexedID;

indexedID : ID '(' expression ')';

content : contentItem*?;

contentItem : possibleStr | BODY;

BODY : ('`' (~'`')*? '{')
     | ('}' (~'`')*? '{')
     | ('}' (~'`')*? '`')
     | ('`' (~'`')*? '`');

ID : [a-zA-Z] [a-zA-Z0-9_]*;
NUM : '-'? [0-9]+;
OP : ('+' | '-' | '*' | '/' | ' Mod '
    | ' Is ' | ' Isn\'t ' | '>=' | '<=' | '>' | '<'
    | ' And ' | ' Or ');
STR : '"' .*? '"';

COMMENT : ('/*' .*? '*/') -> skip;
WS : [ \t\r\n] -> skip;
```

Source Code
--------------------------------
The source code for the language (which contains details about things like translation) can be found in the "IntelliJ" folder. Reading the source gives insight into exactly how the language functions, and is also useful when debugging error messages. Various examples of valid and invalid inputs (i.e., scripts) are given in the "tests" folder of the project.

Typing Details
--------------------------------
The way in which MASL handles identifier typing is intuitive yet somewhat unconventional. Regardless, it is important to understand when writing more complex scripts. The ideal way in which one should read this section is to go example by example, and to avoid hastily generalizing.

Firstly, note that the parser will reject using a value when it is "obviously" the wrong type:
``` MASL
/* rejected by parser */
numId = hello.
listId: 123.
```

This includes cases where it would be possible to do implicit casting of "raw data":
``` MASL
/* rejected by parser */
numId = "123".
```

However, the parser does not do type checking on identifiers, even when a runtime error would occur (this is central to understanding the next example):
``` MASL
/* not rejected by parser */
listId: "hello". /* valid so far */
numId = listId. /* runtime error */
```

The translator performs implicit casting when possible (typically, on identifiers):
``` MASL
/* completely valid */
listId: "123".
numId = listId.
listId2: numId.
```

Snake Game
--------------------------------
To demonstrate the power of MASL, we implemented snake (see "inputs/snake.masl"). At this point, it should be possible to understand exactly what the program does at each point (i.e., how each statement is interpreted), though it may be difficult to understand how things work as a whole. This is because there are many subtle "tricks" (many of which relate to specific typing quirks in MASL) that are required for writing complex programs in MASL. After all, while MASL is very powerful for a DSL, it is small when compared to GPLs. 
``` MASL
/* welcome to snake */

grid: "0", "0", "0", "0", "0",
      "0", "0", "0", "0", "0",
      "0", "0", "2", "0", "0",
      "0", "0", "1", "0", "0",
      "0", "0", "0", "0", "0".

mapping: "*", ".", "#", "#",
         "#", "#", "#", "#", "#", "#",
         "#", "#", "#", "#", "#", "#",
         "#", "#", "#", "#", "#", "#",
         "#", "#", "#", "#", "#", "#".

Begin Template output:
`{mapping (grid (1) + 2)} {mapping (grid (2) + 2)} {mapping (grid (3) + 2)} {mapping (grid (4) + 2)} {mapping (grid (5) + 2)}
{mapping (grid (6) + 2)} {mapping (grid (7) + 2)} {mapping (grid (8) + 2)} {mapping (grid (9) + 2)} {mapping (grid (10) + 2)}
{mapping (grid (11) + 2)} {mapping (grid (12) + 2)} {mapping (grid (13) + 2)} {mapping (grid (14) + 2)} {mapping (grid (15) + 2)}
{mapping (grid (16) + 2)} {mapping (grid (17) + 2)} {mapping (grid (18) + 2)} {mapping (grid (19) + 2)} {mapping (grid (20) + 2)}
{mapping (grid (21) + 2)} {mapping (grid (22) + 2)} {mapping (grid (23) + 2)} {mapping (grid (24) + 2)} {mapping (grid (25) + 2)}`
End Template.

numbers: "1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
         "11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
         "21", "22", "23", "24", "25".

/* snake properties */
headX = 3.
headY = 3.
dirX = 0.
dirY = -1.
length = 2.

/* game properties */
eaten = 1.
active = 1.

Begin Loop, While active:
    /* find fruit location */
    Begin Check, If eaten:
        Randomize numbers.
        index = 1.
        Begin Loop, While grid (numbers (index)) Isn't 0:
            Increment index.
        End Loop.
        Set grid (numbers (index)) To "-1".
        eaten = 0.
    End Check.

    /* manage IO */
    Write output.
    Write "".
    Read input.
    Write "".

    /* process input */
    Begin Check, If input Is 2: /* down */
        Begin Check, If dirY Isn't -1:
            dirX = 0.
            dirY = 1.
        End Check.
    End Check.
    Begin Check, If input Is 8: /* up */
        Begin Check, If dirY Isn't 1:
            dirX = 0.
            dirY = -1.
        End Check.
    End Check.
    Begin Check, If input Is 4: /* left */
        Begin Check, If dirX Isn't 1:
            dirX = -1.
            dirY = 0.
        End Check.
    End Check.
    Begin Check, If input Is 6: /* right */
        Begin Check, If dirX Isn't -1:
            dirX = 1.
            dirY = 0.
        End Check.
    End Check.

    /* calculate head pos */
    headX = headX + dirX.
    headY = headY + dirY.
    gridPos = 5 * headY - 5 + headX.

    /* check out of bounds */
    Begin Check, If headX <= 0:
        Write "You lose!".
        active = 0.
    End Check.
    Begin Check, If headY <= 0:
        Write "You lose!".
        active = 0.
    End Check.
    Begin Check, If headX > 5:
        Write "You lose!".
        active = 0.
    End Check.
    Begin Check, If headY > 5:
        Write "You lose!".
        active = 0.
    End Check.

    Begin Check, If active:
        /* check for fruit */
        shorten = 1.
        Begin Check, If grid (gridPos) Is -1:
            Increment length.
            eaten = 1.
            shorten = 0.
        End Check.

        /* check for win */
        Begin Check, If length Is 25:
            Set grid (gridPos) To length.
            Write output.
            Write "".
            Write "You win!".
            active = 0.
        End Check.

        Begin Check, If active:
            /* shorten snake tail */
            Begin Check, If shorten:
                index = 1.
                Begin Loop, Repeat 25 Times:
                    value = grid (index).
                    Decrement value.
                    Begin Check, If value >= 0:
                        Set grid (index) To value.
                    End Check.
                    Increment index.
                End Loop.
            End Check.

            /* check collision */
            Begin Check, If grid (gridPos) > 0:
                Write "You lose!".
                active = 0.
            End Check.

            /* place snake head */
            Set grid (gridPos) To length.
        End Check.
    End Check.
End Loop.
```

<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>