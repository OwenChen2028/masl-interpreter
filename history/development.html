**DSL Project History**

Authors
=============
<div class="noheader firstcol">
                  |             
------------------|-------------
Team Members      | Owen Chen & Cody Zang
Computer + OS     | Ubuntu, Windows 11 & macOS
Additional Help   | Professor, TAs & Documentation

</div>

Meeting Dates
================
* 7/12/2025, 3-5pm: initial meeting to complete domain selection
* 7/15/2025, 3:30-4pm: meeting with professor, recieved approval
* 7/23/2025, 5-8:30pm: meeting to design and test grammar
* 7/30/2025, 2:15-4:45pm: meeting to develop ANTLR parser and test it
* 8/6/2025, 3-7pm: meeting to develop ANTLR translator and test it
* 8/13/2025, 4:15-5:45pm: meeting to polish and develop final version
* Future dates TBD...

P00: Selection
================
Define the domain.
--------------------------------
Our domain is email automation. Oftentimes in professional settings, email templates and similar tools are used in order to save time communicating. Key considerations in this domain are ease of use/learning (because non-technical staff will be using these tools) and output reliability/correctness (as these emails will be going to clients and other staff). There do exist tools for this sort of task, but they are not languages (more on that later, see below), so our approach the problem seems not to have been done before. 

Define the problem.
--------------------------------
<b>Key Question:</b> What is the purpose of the language?

There are several key issues with existing automation tools for emails. The first is that they are primarily graphical (GUIs) and are not languages (DSLs). The advantage of DSLs for this problem is that they are more portable (e.g., one person from HR can send a text file with the email generating "code" over to another without having to manually transfer settings and populate fields on a graphical interface on the other person's computer). Another is that languages are more powerful, which allows for constructs like basic control flow (such as conditionals) and loops. Our language could even be used by GUI developers as a sort of intermediate representation of what is being automated. We hope that our language will be able to cover a greater number of use cases beyond "find and replace," which existing solutions provide. We do aim to make our DSL less complex than a GPL so that it is easier for non-programmers such as HR teams and marketers to define email templates, however. The output of our DSL will be a set of plaintext files (e.g., personalized emails for each recipient on a list defined by the language user).

Create example inputs, both valid and invalid.
--------------------------------
<b>Key Questions:</b> What is the expected output for some examples of valid input? How will you detect and report those that are invalid?

<b>Valid Comment Input:</b><br>
``` DSL
((comments are in parenthesis because this is intuitive for non-technical staff))
```

<b>Invalid Comment Inputs:</b><br>
``` DSL
(single parentheses do not work because they might be used in the mail body)
// these comments are what programmers are used to, not hr
/* same with these */
# and these
```

<b>Valid List Declaration:</b><br>
``` DSL
((everything is a list of ASCII strings, defined as name: "string1", "string2", "string3"))
((strings in a list can be paired with an <email@domain.coml>))
Subject: "New Start Date For New Employees" ((defining subject line))
Sender: "Company HR" <hr@company.com> ((defining sender))
Recipient: "John" <John@gmail.com>, "Joe" <Joe@gmail.com>, "James" <James@gmail.com> ((defining list of recipients))
```

<b>Invalid List Declaration:</b><br>
``` DSL
subject = "New Start Date" ((this would be GPL-like syntax, not suitable for DSL))
subject: name <email>  ((invalid email syntax))
```

<b>Valid Mail Body Declaration:</b><br>
``` DSL
((defining body for mail, comments do not apply inside body))
Begin Body MailBody (X): ((X is a parameter))
Dear {Recipient (X)}, ((Xth string in recipient list, string over email by default))

Your new official start date is 7/12/2025, Please contact us if you have any questions.

Sincerely,
{Sender} ((places the first string of the list sender here))
{Sender (Email)} ((places the email of the first element in sender here, email is a keyword))
End Body
```

<b>Invalid Mail Body Declaration:</b><br>
``` DSL
MailBody: ((this syntax for lists, does not work with multiple lines))
Dear X,
Hope you are doing well. Your role will be {title}. (({title} has not been defined previously))
Sincerely, Joe
```

<b>Valid Email Generation:</b><br>
``` DSL
Begin Loop with X from 1 to Recipient (Length): ((index X from 1 to length of recipients list))
Generate using MailBody (X) as Body ((generates emails for each recipient in the list))
Print (done with {Recipient (X)}) ((print statement))
End Loop
```

<b>Invalid Email Generation:</b><br>
``` DSL
Generate using MailBody as Body for each Recipient (X) ((this is too informal))
```

<b>Examples of Invalid Semantics:</b><br>
``` DSL
Begin Body Example:
{Recipient (100)} ((out of bounds index))
{ifwhbehjf} ((identifier not defined previously))
{Subject (Email)} ((subject does not have an associated email))
End Body
```

Define functionality.
--------------------------------
<b>Key Questions:</b> How is the output determined for a given input? In other words, how will you demonstrate that your language is working?

We will run our input through a lexer, parser, and then translator in order to generate the output. The lexer will turn the input into tokens, and those tokens will be parsed using ANTLR according to the context-free grammar we define for our language. If the the input as conforms to our language's grammar (examples above), then the translator will attempt to generate output. Otherwise, the input will be rejected with a syntax error (parsing ANTLR is one way in which incorrect outputs will be identified). Then, our translator will go through the parse tree generated by the parser, terminating with a runtime error if there is an undefined identifier, invalid parameter, etc (this is the second way in which incorrect outputs will be identified). If everything is correct, then it will translate the input into a set of plaintext files containing the emails (specifically, the target language is English). At this point, the input will have passed all the steps and be considered "working." Examples of what our translator should be capable of doing include determining what identifiers refer to, resolving if statements, and iterating through loops. 

Talk with the professor, and get approval.
--------------------------------
Done, see meeting dates section.

Include meeting dates and approval dates in readme.
--------------------------------
Done, see meeting dates section.

<br>

P01: Grammar
======================
Create a grammar for the DSL.
--------------------------------
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Pseudocode
program -> statement*

statement -> (‘\n’)* ( declaration
                     | conditional | loop
                     | genStmt | printStmt ) (‘\n’)*

declaration -> numDec | listDec | bodyDec

numDec -> (ID “ = ” expression ‘\n’) | numOp

numOp -> (“Increment ” ID) | (“Decrement ” ID)

listDec -> ID “: ” possibleStr (“, ” possibleStr)* ‘\n’

bodyDec -> “Begin Body ” ID “:\n”
           content ‘\n’
           “End Body\n”

conditional -> “Begin Check ” expression “:\n”
               statement*
               “End Check\n”

loop -> “Begin Loop ” ( “For ” expression “ Times”
                     | “While ” expression ) “:\n”
        statement*
        “End Loop\n”

genStmt -> “Generate ” ID ‘\n’

printStmt -> “Print ” (possibleStr | expression) ‘\n’

expression -> ( possibleNum (OP possibleNum)* )
              | (possibleStr “ In ” ID)

indexedID -> “{ “ ID ‘ (’ (expression | “Count”) ‘)’ “ }”

possibleNum -> NUM | ID | indexedID

possibleStr -> string | ID | indexedID

string -> ‘\“’ CHAR* ‘\”’

content -> (indexedID | CHAR)*

ID -> (a-z | A-Z) (a-z | A-Z | 0-9)*
NUM -> (0-9)+
OP -> ‘ ’ (‘+’ | ‘-’ | ‘*’ | ‘/’ | ‘Mod’
         | ‘Is’ | “>=” | “<=” | ‘>’ | ‘<’
         | ‘And’ | ‘Or’ | ‘Not’) ‘ ’
CHAR -> any ASCII character

skip comment -> “/*” [any character]* “*/”
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Test example inputs against grammar.
--------------------------------
<b>Key Question:</b> Do the valid inputs work and invalid inputs not?<br>

Our grammar changed significantly (see the next subsection), so we designed new inputs and verified that the valid ones work and the invalid ones don't. The three example programs contain various "statements" (which are valid as standalone inputs) to achieve specific functionality, while the examples of syntactically invalid statements fail to conform to the grammar. The semantically invalid statements do pass the grammar, but would lead to runtime errors during our translation step. For example program 1 only (due to how long it takes), I have attached a hand-drawn parse tree showing that it works (the other programs were verified by looking at the grammar).

<b>Hand-Drawn Parse Tree for Example 1:</b><br>
![](screenshots/p01_parsetree.jpg)

<b>Example Program 1 - Personalized Mails w/ Loop:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
recipient: “John”, "Joe", “James”, “Jessie”

Begin Body mail:
Dear { recipient (i) },
This is an email, personalized to you.
End Body

i = 1
Begin Loop For { recipient (Count) } Times:
Generate mail
Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Example Program 2 - Shift Assignment w/ Modulos:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
recipient: “John”, "Joe", “James”, “Jessie”
shift: “day”, “night”

Begin Body mail:
Dear { recipient (i) },
Come in for the { shift (i Mod 2 + 1) } shift tomorrow.
End Body

i = 1
Begin Loop For { recipient (Count) } Times:
Generate mail
Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Example Program 3 - Task Assignment w/ Nested Loops:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
recipient: “John”, "Joe", “James”, “Jessie”
project: “website”, “desktop app”
platform: “Mac”, “Windows”

Begin Body mail:
Dear { recipient (c) },
Your task is to create a { project (i) } for { platform (j) }.
End Body

c = 1
i = 1
Begin Loop For { project (Count) } Times:
j = 1
Begin Loop For { platform (Count) } Times:
Generate mail
Increment c
Increment j
End Loop
Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Examples of Syntactically Invalid Inputs (Rejected by Parser):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* syntax from other languages */
if (i < 0) {
    i = 0;
}
print(i)

/* capitalization errors*/
print i
PRINT i

/* issues with closing statements */
Begin Body invalid1:
*/
End Loop
Begin Check i = 0

/* ignoring whitespace conventions */
BeginBody invalid2: testing 123 EndBody

/* not using curly brackets when indexing */
Print recipients (0)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Examples of Semantically Invalid Inputs (Not Rejected By Parser):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* undefined variable */
Increment var

/* out of bonds index */
Print { recipients (100) }

/* division by 0 */
i = 1 / 0

/* boolean algebra with whole numbers */
i = 1 And 2

/* incorrect type of identifier */
string: “hello”
recipients(string)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Do you have to make corrections or changes?
--------------------------------
Numerous changes were made to the grammar for various reasons, such as for removing ambiguity in parsing/writing inputs. Several features were added for increased usability, and several were removed due to introducing complications (+ minor syntax changes). 

Here the changes that we've deemed notable:
* Integers and expressions have been added because they are extremely useful for many automation tasks. Integer declaration is done by assigning an identifier to an initial value with ‘=’ (type is inferred). They can be incremented and decremented using "Increment" and "Decrement" (they are unary operators that go before the identifier). Expressions support multiple binary operations in sequence from left to right including arithmetic, logic, and comparisons (parenthesis are not supported to discourage convoluted equations and reduce translation complexity, 0 and 1 are treated as booleans for logic operators and comparison results). 
* Nested statements, including nested loops, are now possible. As seen in the 3rd example program, Iterating over all combinations of things in lists is a common task that are language is not capable of. Nested conditionals are also supported; a result of this is that our language is very powerful, capable of some GPL tasks. 
* Bodies no longer have parameters. To achieve the same functionality, indexing will be evaluated at runtime, so declaring a variable with the former parameter's name and modifying that variable will result in the same behavior (our examples all show this behavior for personalized recipient names). 
* There is no longer whitespace, as ignoring spaces and new lines would lead to poorly formatted mail bodies. Enforcing whitespace rules also allows for neater code, which is something that we want to “encourage.”
* ((This is no longer a comment)) /* This is. It looks much better, it's not actually that difficult for non-programmers to learn, and most importantly, people won’t confuse it with mathematical notation and try to use it in expressions. */
* Pairing strings with emails (and having a special email type) is deprecated. Emails can simply be stored as strings in a separate list, so pairing adds too much translation complexity for no good reason. 

<br>

P02: Parser
======================
Use ANTLR to generate a parser for the language.
--------------------------------
<b>ANTLR Grammar:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ANTLR
grammar DSL;

parse : statement* EOF;

statement : (' ' | ENDL)* ( declaration
                          | conditional | loop
                          | genStmt | printStmt ) '.' ENDL*;

declaration : numDec | listDec | templateDec;

numDec : ( (ID ' = ' expression) | numOp );

numOp : ('Increment ' ID) | ('Decrement ' ID);

listDec : ID ': ' possibleStr (', ' possibleStr)*;

templateDec : 'Begin Template ' ID ':' ENDL*
          (' ' | ENDL)* content ENDL* (' ' | ENDL)*
          'End Template';

conditional : 'Begin Check, If [' expression ']:' ENDL*
              statement*? (' ' | ENDL)*
              'End Check';

loop : 'Begin Loop, ' ( 'Repeat [' expression '] Times'
                      | 'While [' expression ']' ) ':' ENDL*
        statement*? (' ' | ENDL)*
        'End Loop';
        
genStmt : 'Generate ' ID;

printStmt : 'Print ' (possibleStr | expression);

expression : ( possibleNum (OP possibleNum)* )
           | ( possibleStr ' In ' ID );

possibleNum : NUM | ID | indexedID;

possibleStr : STR | ID | indexedID;

content : (substitution | CNT)*?;

substitution : (ID | indexedID);

indexedID : ID ' (' (expression | ('"Count"' | '"Random"')) ')';

CNT : ('`' .*? '{')
    | ('}' .*? '{')
    | ('}' .*? '`')
    | ('`' .*? '`');

ID : [a-zA-Z] [a-zA-Z0-9]*;
NUM : [0-9]+;
OP : ' ' ('+' | '-' | '*' | '/' | 'Mod'
         | 'Is' | '>=' | '<=' | '>' | '<'
         | 'And' | 'Or' | 'Not') ' ';
STR : '"' .*? '"';
ENDL : ('\r')? '\n';

COMMENT : '/*' .*? '*/' -> skip;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The above grammar is a translated version of the P001 grammar, with various changes to make it compatible with ANTLR and resolve parsing ambiguities. 

Test the parser for agreement with the design.
--------------------------------
<b>Testing Code:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Java
import org.antlr.v4.runtime.*;
import java.io.File;
import java.io.FileInputStream;

public class Test {
    public static void parseHelper(String file) throws Exception {
        FileInputStream in = new FileInputStream(file);
        CharStream input = CharStreams.fromStream(in);
        DSLLexer lexer  = new DSLLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        DSLParser parser = new DSLParser(tokens);
        parser.parse();
    }

    public static void main(String[] args) throws Exception {
        File validDir = new File("tests/valid/");
        File[] validFiles = validDir.listFiles();
        if (validFiles != null) {
            for (File file : validFiles) {
                System.out.println("Testing File (Valid Input): " + file.getName());
                parseHelper(file.getPath());
                Thread.sleep(10);
                System.out.println("Done: Expect No Error.\n");
            }
        }

        File invalidDir = new File("tests/invalid/");
        File[] invalidFiles = invalidDir.listFiles();
        if (invalidFiles != null) {
            for (File file : invalidFiles) {
                System.out.println("Testing File (Invalid Input): " + file.getPath());
                parseHelper(file.getPath());
                Thread.sleep(10);
                System.out.println("Done: Expect Error Above.\n");
            }
        }
    };
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Screenshot (Test Results pt. 1):</b><br>
![](screenshots/p02_testresults1.png)

<b>Screenshot (Test Results pt. 2):</b><br>
![](screenshots/p02_testresults2.png)

<b>Screenshot (Test Results pt. 3):</b><br>
![](screenshots/p02_testresults2.png)

<b>Screenshot (Parse Tree for Program 1):</b><br>
![](screenshots/p02_parsetree1.png)

<b>Screenshot (Parse Tree for Program 2):</b><br>
![](screenshots/p02_parsetree2.png)

<b>Screenshot (Parse Tree for Program 3):</b><br>
![](screenshots/p02_parsetree3.png)

After some debugging, the parser now accepts and rejects inputs as expected. See below for information on the exact tests.

Create more valid and invalid inputs that fully test your language design.
--------------------------------
Because of grammar changes, the tests created for the last milestone's grammar no longer work. We had to create new tests and modify old tests to test the ANTLR parser. We ended up with 3 valid input programs (which contain multiple statements that would work as standalone examples), 1 valid input example of a language feature, and 8 invalid input examples. See below for the exact tests (the exact behavior being tested in described in the comments). They are located in the "tests" folder of the IntelliJ project. 

<b>Valid Input: defaultidx.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: un-indexed list ID defaults to first element */
hi: "Hello World".
Print hi.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Valid Input: program1.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: personalized recipients */

recipient: "John", "Joe", "James", "Jessie".

Begin Template mail:
`Dear {recipient (i)},
This is an email, personalized to you.`
End Template.

i = 1.
Begin Loop, Repeat [recipient ("Count")] Times:
    Generate mail.
    Increment i.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Valid Input: program2.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: shift assignment */

recipient: "John", "Joe", "James", "Jessie".
shift: "day", "night".

Begin Template mail:
`Dear {recipient (i)},
Come in for the {shift (i Mod 2 + 1)} shift tomorrow.`
End Template.

i = 1.
Begin Loop, Repeat [recipient ("Count")] Times:
    Generate mail.
    Increment i.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Valid Input: program3.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: task assignment */

recipient: "John", "Joe", "James", "Jessie".
project: "website", "desktop app".
platform: "Mac", "Windows".

Begin Template mail:
`Dear {recipient (c)},
Your task is to create a {project (i)} for {platform (j)}.`
End Template.

c = 1.
i = 1.
Begin Loop, Repeat [project ("Count")] Times:
    j = 1.
    Begin Loop, Repeat [platform ("Count")] Times:
        Generate mail.
        Increment c.
        Increment j.
    End Loop.
    Increment i.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: allcapserror.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid due to case mismatch */
PRINT "Hello World".
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: cstyleifstmt.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: if statement using c style syntax */
if (i < 0) {
    i = 0;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: exprparens.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: parenthesis not supported in expressions */
num = 32487 + (87239 / 1374).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: invalidtype.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: declaring list of numbers */
numbers: 1, 2, 3, 4.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: noloopend.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: loop not terminated */
Begin Loop, Repeat [recipient ("Count")] Times:
    Generate mail.
    Increment i.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: notenclosed.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: content not enclosed with backticks */
Begin Template mail:
Dear {recipient (i)},
This is an email, personalized to you.
End Template.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: noterminate.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: statements not terminated with periods */
Begin Loop, Repeat [recipient ("Count")] Times:
    Generate mail
    Increment i
End Loop
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Invalid Input: printparens.dsl</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* invalid: print enclosed in parentheses */
Print("Hello").
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

P03: Prototype
======================
Generate a translator based on the desired functionality and examples.
--------------------------------
<b>Updated ANTLR Grammar:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ANTLR
    grammar DSL;

    program : statement* EOF;

    statement : ( declaration
                | operation
                | conditional | loop
                | genStmt | ioStmt ) '.';

    declaration : numDec | listDec | templateDec;

    numDec : ID '=' expression;

    listDec : ID ':' possibleStr (',' possibleStr)*;

    operation : numOp | listOp;

    numOp : incOp | decOp;

    incOp : 'Increment ' ID;

    decOp : 'Decrement ' ID;

    listOp : setOp | randOp;

    setOp : 'Set ' ID ' To ' possibleStr ' At ' expression;

    randOp : 'Shuffle ' ID;

    templateDec : 'Begin Template ' ID ':'
                  content
                  'End Template';

    conditional : 'Begin Check,'
                  'If ' expression ':'
                  statement*?
                  'End Check';

    loop : repeatLoop | whileLoop;

    repeatLoop : 'Begin Loop,'
                 'Repeat ' expression ' Times:'
                 statement*?
                 'End Loop';

    whileLoop : 'Begin Loop,'
                'While ' expression ':'
                statement*?
                'End Loop';

    genStmt : 'Generate ' ID;

    ioStmt : readStmt | writeStmt;

    readStmt : 'Read ' ID;

    writeStmt : 'Write ' (possibleStr | expression);

    expression : possibleNum (OP possibleNum)*;

    possibleNum : NUM | ID | indexedID;

    possibleStr : STR | ID | indexedID;

    indexedID : ID '(' expression ')';

    content : contentItem*?;

    contentItem : possibleStr | BODY;

    BODY : ('`' (~'`')*? '{')
         | ('}' (~'`')*? '{')
         | ('}' (~'`')*? '`')
         | ('`' (~'`')*? '`');

    ID : [a-zA-Z] [a-zA-Z0-9]*;
    NUM : '-'? [0-9]+;
    OP : ('+' | '-' | '*' | '/' | ' Mod '
        | ' Is ' | ' Isn\'t ' | '>=' | '<=' | '>' | '<'
        | ' And ' | ' Or ');
    STR : '"' .*? '"';

    COMMENT : ('/*' .*? '*/') -> skip;
    WS : [ \t\r\n] -> skip;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>ANTLR Translator:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Java
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.RuleNode;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.util.*;

public class Translator implements DSLVisitor< Integer > {
    HashMap< String, Integer > numIds = new HashMap<>();
    HashMap< String, List< String > > listIds = new HashMap<>();
    HashMap< String, DSLParser.ContentContext > templateIds = new HashMap<>();

    Scanner scanner = new Scanner(System.in);

    @Override
    public Integer visitProgram(DSLParser.ProgramContext ctx) {
        for (DSLParser.StatementContext stmtCtx : ctx.statement()) {
            visitStatement(stmtCtx);
        }
        return null;
    }

    @Override
    public Integer visitStatement(DSLParser.StatementContext ctx) {
        if (ctx.declaration() != null) {
            visitDeclaration(ctx.declaration());
        }
        else if (ctx.operation() != null) {
            visitOperation(ctx.operation());
        }
        else if (ctx.conditional() != null) {
            visitConditional(ctx.conditional());
        }
        else if (ctx.loop() != null) {
            visitLoop(ctx.loop());
        }
        else if (ctx.genStmt() != null) {
            visitGenStmt(ctx.genStmt());
        }
        else if (ctx.ioStmt() != null) {
            visitIoStmt(ctx.ioStmt());
        }
        return null;
    }

    @Override
    public Integer visitDeclaration(DSLParser.DeclarationContext ctx) {
        if (ctx.numDec() != null) {
            visitNumDec(ctx.numDec());
        }
        else if (ctx.listDec() != null) {
            visitListDec(ctx.listDec());
        }
        else if (ctx.templateDec() != null) {
            visitTemplateDec(ctx.templateDec());
        }
        return null;
    }

    @Override
    public Integer visitNumDec(DSLParser.NumDecContext ctx) {
        String numId = ctx.ID().getText();
        Integer exprResult = visitExpression(ctx.expression());

        if (exprResult != null) {
            if (listIds.containsKey(numId) || templateIds.containsKey(numId)) {
                throw new RuntimeException(String.format("\"%s\" is already defined with a different type", numId));
            }
            else {
                numIds.put(numId, exprResult);
            }
        }
        else {
            throw new RuntimeException(String.format("initializer for \"%s\" evaluated to null (expected an integer)", numId));
        }

        return null;
    }

    @Override
    public Integer visitListDec(DSLParser.ListDecContext ctx) {
        String listId = ctx.ID().getText();
        List< String > strList = new ArrayList<>();

        for (DSLParser.PossibleStrContext strCtx : ctx.possibleStr()) {
            visitPossibleStr(strCtx);
            if (possibleStrResult != null) {
                strList.add(possibleStrResult);
            }
            else {
                throw new RuntimeException(String.format("initializer for an element in \"%s\" evaluated to null (expected a string)", listId));
            }
        }


        if (numIds.containsKey(listId) || templateIds.containsKey(listId)) {
            throw new RuntimeException(String.format("\"%s\" is already defined with a different type", listId));
        }
        else {
            listIds.put(listId, strList);
        }

        return null;
    }

    @Override
    public Integer visitOperation(DSLParser.OperationContext ctx) {
        if (ctx.numOp() != null) {
            visitNumOp(ctx.numOp());
        }
        else if (ctx.listOp() != null) {
            visitListOp(ctx.listOp());
        }
        return null;
    }

    @Override
    public Integer visitNumOp(DSLParser.NumOpContext ctx) {
        if (ctx.incOp() != null) {
            visitIncOp(ctx.incOp());
        }
        else if (ctx.decOp() != null) {
            visitDecOp(ctx.decOp());
        }
        return null;
    }

    @Override
    public Integer visitIncOp(DSLParser.IncOpContext ctx) {
        String numID = ctx.ID().getText();
        if (numIds.containsKey(numID)) {
            numIds.put(numID, numIds.get(numID) + 1);
        }
        else {
            throw new RuntimeException(String.format("no numeric variable named \"%s\" has been declared", numID));
        }
        return null;
    }

    @Override
    public Integer visitDecOp(DSLParser.DecOpContext ctx) {
        String numID = ctx.ID().getText();
        if (numIds.containsKey(numID)) {
            numIds.put(numID, numIds.get(numID) - 1);
        }
        else {
            throw new RuntimeException(String.format("no numeric variable named \"%s\" has been declared", numID));
        }
        return null;
    }

    @Override
    public Integer visitListOp(DSLParser.ListOpContext ctx) {
        if (ctx.setOp() != null) {
            visitSetOp(ctx.setOp());
        }
        else if (ctx.randOp() != null) {
            visitRandOp(ctx.randOp());
        }
        return null;
    }

    @Override
    public Integer visitSetOp(DSLParser.SetOpContext ctx) {
        String listId = ctx.ID().getText();
        if (listIds.containsKey(listId)) {
            Integer listIndex = visitExpression(ctx.expression());
            if (listIndex == null) {
                throw new RuntimeException(String.format("index for \"%s\" evaluated to null (expected a 1-based integer)", listId));
            }
            else if (listIndex >= 1 && listIndex <= listIds.get(listId).size()) {
                visitPossibleStr(ctx.possibleStr());
                if (possibleStrResult != null) {
                    listIds.get(listId).set(listIndex - 1, possibleStrResult);
                }
                else {
                    throw new RuntimeException(String.format("assignment to \"%s[%d]\" evaluated to null (lists cannot store null strings)", listId, listIndex));
                }
            }
            else {
                throw new RuntimeException(String.format("index %d is out of bounds (valid range for \"%s\" is 1 to %d)", listIndex, listId, listIds.get(listId).size()));
            }
        }
        else {
            throw new RuntimeException(String.format("no list named \"%s\" has been declared", listId));
        }
        return null;
    }

    @Override
    public Integer visitRandOp(DSLParser.RandOpContext ctx) {
        String listId = ctx.ID().getText();
        if (listIds.containsKey(listId)) {
            Collections.shuffle(listIds.get(listId));
        }
        else {
            throw new RuntimeException(String.format("no list named \"%s\" has been declared", listId));
        }
        return null;
    }

    @Override
    public Integer visitTemplateDec(DSLParser.TemplateDecContext ctx) {
        String templateId = ctx.ID().getText();
        if (numIds.containsKey(templateId) || listIds.containsKey(templateId)) {
            throw new RuntimeException(String.format("\"%s\" is already defined with a different type", templateId));
        }
        else {
            templateIds.put(templateId, ctx.content());
        }
        return null;
    }

    @Override
    public Integer visitConditional(DSLParser.ConditionalContext ctx) {
        Integer exprResult = visitExpression(ctx.expression());
        if (exprResult == null) {
            throw new RuntimeException("condition in check block evaluated to null (expected 0 or 1)");
        }
        else if (exprResult == 1) { // true
            for (DSLParser.StatementContext stmtCtx : ctx.statement()) {
                visitStatement(stmtCtx);
            }
        }
        else if (exprResult != 0) { // not true or false
            throw new RuntimeException(String.format("condition in check block evaluated to %d (expected 0 or 1)", exprResult));
        }
        return null;
    }

    @Override
    public Integer visitLoop(DSLParser.LoopContext ctx) {
        if (ctx.repeatLoop() != null) {
            visitRepeatLoop(ctx.repeatLoop());
        }
        else if (ctx.whileLoop() != null) {
            visitWhileLoop(ctx.whileLoop());
        }
        return null;
    }

    @Override
    public Integer visitRepeatLoop(DSLParser.RepeatLoopContext ctx) {
        Integer exprResult = visitExpression(ctx.expression());
        if (exprResult == null) {
            throw new RuntimeException("repeat loop count evaluated to null (expected ≥ 0)");
        }
        else if (exprResult >= 0) {
            for (int i = 0; i < exprResult; i++) {
                for (DSLParser.StatementContext stmtCtx : ctx.statement()) {
                    visitStatement(stmtCtx);
                }
            }
        }
        else {
            throw new RuntimeException(String.format("repeat loop count is %d (expected ≥ 0)", exprResult));
        }
        return null;
    }

    @Override
    public Integer visitWhileLoop(DSLParser.WhileLoopContext ctx) {
        int iter = 0;
        Integer exprResult;
        while (true) {
            exprResult = visitExpression(ctx.expression());
            if (exprResult == null) {
                throw new RuntimeException("while condition evaluated to null (expected 0 or 1)");
            }
            else if (exprResult == 0) {
                break;
            }
            else if (exprResult == 1) {
                if (iter >= 1000) {
                    throw new RuntimeException("while loop exceeded 1000 iterations (possible infinite loop)");
                }
                for (DSLParser.StatementContext stmtCtx : ctx.statement()) {
                    visitStatement(stmtCtx);
                }
                iter++;
            }
            else {
                throw new RuntimeException(String.format("while condition evaluated to %d (expected 0 or 1)", exprResult));
            }
        }
        return null;
    }

    @Override
    public Integer visitGenStmt(DSLParser.GenStmtContext ctx) {
        String templateId = ctx.ID().getText();
        if (templateIds.containsKey(templateId)) {
            visitContent(templateIds.get(templateId));
            if (contentResult != null) {
                System.out.println(contentResult);
            }
            else {
                throw new RuntimeException(String.format("template \"%s\" produced null content (check placeholders)", templateId));
            }
        }
        else {
            throw new RuntimeException(String.format("no template named \"%s\" has been declared", templateId));
        }
        return null; // TODO: generate actual files
    }

    @Override
    public Integer visitIoStmt(DSLParser.IoStmtContext ctx) {
        if (ctx.readStmt() != null) {
            visitReadStmt(ctx.readStmt());
        }
        else if (ctx.writeStmt() != null) {
            visitWriteStmt(ctx.writeStmt());
        }
        return null;
    }

    @Override
    public Integer visitReadStmt(DSLParser.ReadStmtContext ctx) {
        String id = ctx.ID().getText();
        if (numIds.containsKey(id) || templateIds.containsKey(id)) {
            throw new RuntimeException(String.format("\"%s\" is already defined with a different type", id));
        }
        else {
            System.out.print("Input: ");
            listIds.put(id, new ArrayList<>(
                    Collections.singletonList(scanner.nextLine())
            ));
        }
        return null;
    }

    @Override
    public Integer visitWriteStmt(DSLParser.WriteStmtContext ctx) {
        if (ctx.possibleStr() != null) {
            visitPossibleStr(ctx.possibleStr());
            if (possibleStrResult != null) {
                System.out.println(possibleStrResult);
            }
            else {
                throw new RuntimeException("write statement evaluated to null (expected a string)");
            }
        }
        else if (ctx.expression() != null) {
            Integer exprResult = visitExpression(ctx.expression());
            if (exprResult != null) {
                System.out.println(exprResult);
            }
            else {
                throw new RuntimeException("write statement evaluated to null (expected an integer)");
            }
        }
        return null;
    }

    @Override
    public Integer visitExpression(DSLParser.ExpressionContext ctx) {
        List< DSLParser.PossibleNumContext > nums = ctx.possibleNum();
        List< TerminalNode > ops  = ctx.OP();

        Integer value = visitPossibleNum(nums.get(0));
        if (value == null) {
            throw new RuntimeException("expression segment resolved to null");
        }

        for (int i = 1; i < nums.size(); i++) {
            Integer next = visitPossibleNum(nums.get(i));
            if (next == null) {
                throw new RuntimeException("expression segment resolved to null");
            }
            else {
                switch (ops.get(i - 1).getText().replaceAll(" ", "")) {
                    case "+":
                        value += next;
                        break;
                    case "-":
                        value -= next;
                        break;
                    case "*":
                        value *= next;
                        break;
                    case "/":
                        if (next != 0) {
                            value /= next;
                        }
                        else {
                            throw new RuntimeException("attempted division by zero in expression");
                        }
                        break;
                    case "Mod":
                        if (next != 0) {
                            value %= next;
                        }
                        else {
                            throw new RuntimeException("attempted modulus by zero in expression");
                        }
                        break;
                    case "Is":
                        value = (value.equals(next)) ? 1 : 0;
                        break;
                    case "Isn't":
                        value = (value.equals(next)) ? 0 : 1;
                        break;
                    case ">=":
                        value = (value >= next) ? 1 : 0;
                        break;
                    case "<=":
                        value = (value <= next) ? 1 : 0;
                        break;
                    case ">":
                        value = (value > next) ? 1 : 0;
                        break;
                    case "<":
                        value = (value < next) ? 1 : 0;
                        break;
                    case "And":
                        if (isBoolean(value) && isBoolean(next)) {
                            value = (value == 1 && next == 1) ? 1 : 0;
                        }
                        else {
                            throw new RuntimeException(String.format("logical operator received %d and %d (expected 0 or 1)", value, next));
                        }
                        break;
                    case "Or":
                        if (isBoolean(value) && isBoolean(next)) {
                            value = (value == 1 || next == 1) ? 1 : 0;
                        }
                        else {
                            throw new RuntimeException(String.format("logical operator received %d and %d (expected 0 or 1)", value, next));
                        }
                        break;
                    default:
                        throw new RuntimeException(String.format("unrecognised operator \"%s\"", ops.get(i - 1).getText()));
                }
            }
        }

        return value;
    }

    private static boolean isBoolean(int v) {
        return v == 0 || v == 1;
    }

    @Override
    public Integer visitPossibleNum(DSLParser.PossibleNumContext ctx) {
        if (ctx.NUM() != null) {
            return Integer.parseInt(ctx.NUM().getText());
        }
        if (ctx.ID() != null) {
            String numId = ctx.ID().getText();
            if (numIds.containsKey(numId)) {
                return numIds.get(numId);
            }
            else {
                if (listIds.containsKey(numId)) {
                    try {
                        return Integer.parseInt(listIds.get(numId).get(0));
                    }
                    catch (NumberFormatException e) {
                        throw new RuntimeException(String.format("first element of list \"%s\" is not a valid integer", numId));
                    }
                }
                else {
                    throw new RuntimeException(String.format("identifier \"%s\" is undefined", numId));
                }
            }
        }
        else if (ctx.indexedID() != null) {
            visitIndexedID(ctx.indexedID());
            if (possibleIndexingResult != null) {
                try {
                    return Integer.parseInt(possibleIndexingResult);
                }
                catch (NumberFormatException e) {
                    throw new RuntimeException(String.format("value at \"%s[index]\" is not an integer", ctx.indexedID().ID().getText()));
                }
            }
            else {
                throw new RuntimeException(String.format("evaluation of \"%s(index)\" returned null", ctx.indexedID().ID().getText()));
            }
        }
        return null;
    }

    String possibleStrResult = null;

    @Override
    public Integer visitPossibleStr(DSLParser.PossibleStrContext ctx) {
        possibleStrResult = null;
        if (ctx.STR() != null) {
            possibleStrResult = ctx.STR().getText().replaceAll("\"", "");
        }
        else if (ctx.ID() != null) {
            String id = ctx.ID().getText();
            if (listIds.containsKey(id)) {
                possibleStrResult = listIds.get(id).get(0);
            }
            else if (numIds.containsKey(id)) {
                possibleStrResult = String.valueOf(numIds.get(id));
            }
            else if (templateIds.containsKey(id)) {
                visitContent(templateIds.get(id));
                if (contentResult != null) {
                    possibleStrResult = contentResult;
                }
                else {
                    throw new RuntimeException(String.format("template \"%s\" produced null content (check placeholders)", id));
                }
            }
            else {
                throw new RuntimeException(String.format("identifier \"%s\" is undefined", id));
            }
        }
        else if (ctx.indexedID() != null) {
            visitIndexedID(ctx.indexedID());
            if (possibleIndexingResult != null) {
                possibleStrResult = possibleIndexingResult;
            }
            else {
                throw new RuntimeException(String.format("evaluation of \"%s(index)\" returned null", ctx.indexedID().ID().getText()));
            }
        }
        return null;
    }

    String contentResult = null;

    @Override
    public Integer visitContent(DSLParser.ContentContext ctx) {
        contentResult = "";
        for (DSLParser.ContentItemContext itemCtx : ctx.contentItem()) {
            visitContentItem(itemCtx);
            if (itemResult != null) {
                contentResult += itemResult;
            }
            else {
                contentResult = null;
                throw new RuntimeException("template content contains a null segment");
            }
        }
        return null;
    }

    String itemResult = null;

    @Override
    public Integer visitContentItem(DSLParser.ContentItemContext ctx) {
        itemResult = null;
        if (ctx.possibleStr() != null) {
            visitPossibleStr(ctx.possibleStr());
            if (possibleStrResult != null) {
                itemResult = possibleStrResult;
            }
            else {
                throw new RuntimeException("template content contains a null segment");
            }
        }
        else if (ctx.BODY() != null) {
            itemResult = ctx.BODY().getText()
                    .replaceAll("`", "")
                    .replaceAll("\\{", "")
                    .replaceAll("}", "");
        }
        return null;
    }

    String possibleIndexingResult = null;

    @Override
    public Integer visitIndexedID(DSLParser.IndexedIDContext ctx) {
        possibleIndexingResult = null;
        String listId = ctx.ID().getText();
        if (listIds.containsKey(listId)) {
            Integer listIndex = visitExpression(ctx.expression());
            if (listIndex != null) {
                if (listIndex >= 1 && listIndex <= listIds.get(listId).size()) {
                    possibleIndexingResult = listIds.get(listId).get(listIndex - 1);
                }
                else {
                    throw new RuntimeException(String.format("index %d is out of bounds (valid range for \"%s\" is 1 to %d)", listIndex, listId, listIds.get(listId).size()));
                }
            }
            else {
                throw new RuntimeException(String.format("list index for \"%s\" evaluated to null (expected ≥ 1)", listId));
            }
        }
        else {
            throw new RuntimeException(String.format("no list named \"%s\" has been declared", listId));
        }
        return null;
    }

    @Override public Integer visit(ParseTree tree) { return null; }
    @Override public Integer visitChildren(RuleNode node) { return null; }
    @Override public Integer visitTerminal(TerminalNode node) { return null; }
    @Override public Integer visitErrorNode(ErrorNode node) { return null; }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Testing Code:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Java
import org.antlr.v4.runtime.*;

import java.io.FileInputStream;

public class Interpreter {
    public static void main(String[] args) throws Exception {
        FileInputStream in = new FileInputStream(args[0]);
        CharStream input = CharStreams.fromStream(in);
        DSLLexer lexer  = new DSLLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        DSLParser parser = new DSLParser(tokens);

        try {
            DSLParser.ProgramContext tree = parser.program();
            Translator translator = new Translator();
            translator.visitProgram(tree);
        }
        catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
        }
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Although a listener is generally easier to implement, we had to use a visitor because of the delayed evaluation of templates. Because we use many complex constructs, it was actually fairly difficult to implement things at times and required a lot of design work. Some key challenges were handling type ambiguity and robust error handling. Note that we also had to rework some parts of the grammar for both better translation and to achieve more complete functionality. 

Test the translator against your trivial inputs (valid and invalid).
--------------------------------
In addition to expanding the testing suite with cases to check new features, the possibility of syntactically valid but semantically invalid programs is now relevant. Syntax errors are correctly detected by the parser, so we focused on checking the output correctness of tests that pass the grammar for this section. For simplicity, generate statements print to console instead of writing to files (by the next milestone, file generation will be implemented). Some example tests are shown below:

<b>program1.dsl (Valid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: personalized recipients */

recipient: "John", "Joe", "James", "Jessie".

Begin Template mail:
`Dear {recipient (i)},
This is an email, personalized to you.`
End Template.

i = 1.
Begin Loop,
Repeat 4 Times:
    Generate mail.
    Increment i.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Verified Output:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
Dear John,
This is an email, personalized to you.
Dear Joe,
This is an email, personalized to you.
Dear James,
This is an email, personalized to you.
Dear Jessie,
This is an email, personalized to you.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>program2.dsl (Valid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: shift assignment */

recipient: "John", "Joe", "James", "Jessie".
shift: "day", "night".

Shuffle recipient.

Begin Template mail:
`Dear {recipient (i)},
Come in for the {shift (i Mod 2 + 1)} shift tomorrow.`
End Template.

i = 1.
Begin Loop,
Repeat 4 Times:
    Generate mail.
    Increment i.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Verified Output:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
Dear Jessie,
Come in for the night shift tomorrow.
Dear Joe,
Come in for the day shift tomorrow.
Dear John,
Come in for the night shift tomorrow.
Dear James,
Come in for the day shift tomorrow.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>program3.dsl (Valid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: task assignment */

recipient: "John", "Joe", "James", "Jessie".
project: "website", "desktop app".
platform: "Mac", "Windows".

Begin Template mail:
`Dear {recipient (c)},
Your task is to create a {project (i)} for {platform (j)}.`
End Template.

c = 1.
i = 1.
Begin Loop,
Repeat 2 Times:
    j = 1.
    Begin Loop,
    Repeat 2 Times:
        Generate mail.
        Increment c.
        Increment j.
    End Loop.
    Increment i.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Verified Output:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
Dear John,
Your task is to create a website for Mac.
Dear Joe,
Your task is to create a website for Windows.
Dear James,
Your task is to create a desktop app for Mac.
Dear Jessie,
Your task is to create a desktop app for Windows.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>otherbehav.dsl (Valid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* set element in list */
list: "ab", "cd", "ef".
Write list (2).
Set list To "gh" At 2.
Write list (2).

Write "".

/* if statement */
Begin Check,
If 1 + 1 Is 2:
    Write "yes!".
End Check.

Write "".

/* while loop */
i = 1.
Begin Loop,
While i <= 3:
    Write list (i).
    Increment i.
End Loop.

Write "".

/* shuffle list randomly */
Shuffle list.
Write list (1).
Write list (2).
Write list (3).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Verified Output:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
cd
gh

yes!

ab
gh
ef

ef
gh
ab
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>implicitcast.dsl (Valid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* when possible, strings can function as numbers */
str: "1234".
num = str + 1111.
Write num.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Verified Output:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
2345
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>defaultidx.dsl (Valid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* valid: list ID defaults to first element */
hi: "Hello World".
Write hi.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Verified Output:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
Hello World
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>undecliden.dsl (Invalid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* undeclared identifier */
Set list To "hi" At 1.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Error Message:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
no list named "list" has been declared
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>dividebyzero.dsl (Invalid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* dividing by zero */
i = 1 / 0.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Error Message:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
attempted division by zero in expression
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>integerlogic.dsl (Invalid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* integers in boolean logic */
i = 1 And 2.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Error Message:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
logical operator received 1 and 2 (expected 0 or 1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>outofbounds.dsl (Invalid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* index out of bounds */
list: "1".
Write list (2).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Error Message:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
index 2 is out of bounds (valid range for "list" is 1 to 1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>invalidtype.dsl (Invalid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* identifier with wrong type */
l1: "a".
l2: "b".
Write l2 (l1).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Error Message:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
first element of list "l1" is not a valid integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

<b>infiniteloop.dsl (Invalid):</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* infinite while loop */
Begin Loop, While 1:
    i = 1.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Error Message:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Text
while loop exceeded 1000 iterations (possible infinite loop)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Begin testing against non-trivial inputs.
--------------------------------
To stress test language features, we built two ASCII-based games (snake and tic tac toe), which work suprisingly well. In the release version, expect these to be bug free except for input sanitization, which we aren't prioritizing. The code itself isn't supposed to look too great as our domain is mail automation and users are not intended to write programs like the following. See below:

<b>snake.dsl:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* welcome to snake */

grid: "0", "0", "0", "0", "0",
      "0", "0", "0", "0", "0",
      "0", "0", "2", "0", "0",
      "0", "0", "1", "0", "0",
      "0", "0", "0", "0", "0".

mapping: "*", ".", "#", "#",
         "#", "#", "#", "#", "#", "#",
         "#", "#", "#", "#", "#", "#",
         "#", "#", "#", "#", "#", "#",
         "#", "#", "#", "#", "#", "#".

Begin Template output:
`{mapping (grid (1) + 2)} {mapping (grid (2) + 2)} {mapping (grid (3) + 2)} {mapping (grid (4) + 2)} {mapping (grid (5) + 2)}
{mapping (grid (6) + 2)} {mapping (grid (7) + 2)} {mapping (grid (8) + 2)} {mapping (grid (9) + 2)} {mapping (grid (10) + 2)}
{mapping (grid (11) + 2)} {mapping (grid (12) + 2)} {mapping (grid (13) + 2)} {mapping (grid (14) + 2)} {mapping (grid (15) + 2)}
{mapping (grid (16) + 2)} {mapping (grid (17) + 2)} {mapping (grid (18) + 2)} {mapping (grid (19) + 2)} {mapping (grid (20) + 2)}
{mapping (grid (21) + 2)} {mapping (grid (22) + 2)} {mapping (grid (23) + 2)} {mapping (grid (24) + 2)} {mapping (grid (25) + 2)}`
End Template.

numbers: "1", "2", "3", "4", "5", "6", "7", "8", "9", "10",
         "11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
         "21", "22", "23", "24", "25".

/* snake properties */
headX = 3.
headY = 3.
dirX = 0.
dirY = -1.
length = 2.

/* game properties */
eaten = 1.
active = 1.

Begin Loop, While active:
    /* find fruit location */
    Begin Check, If eaten:
        Shuffle numbers.
        index = 1.
        Begin Loop, While grid (numbers (index)) Isn't 0:
            Increment index.
        End Loop.
        Set grid To "-1" At numbers (index).
        eaten = 0.
    End Check.

    /* manage IO */
    Write output.
    Write "".
    Read input.
    Write "".

    /* process input */
    Begin Check, If input Is 2: /* down */
        Begin Check, If dirY Isn't -1:
            dirX = 0.
            dirY = 1.
        End Check.
    End Check.
    Begin Check, If input Is 8: /* up */
        Begin Check, If dirY Isn't 1:
            dirX = 0.
            dirY = -1.
        End Check.
    End Check.
    Begin Check, If input Is 4: /* left */
        Begin Check, If dirX Isn't 1:
            dirX = -1.
            dirY = 0.
        End Check.
    End Check.
    Begin Check, If input Is 6: /* right */
        Begin Check, If dirX Isn't -1:
            dirX = 1.
            dirY = 0.
        End Check.
    End Check.

    /* calculate head pos */
    headX = headX + dirX.
    headY = headY + dirY.
    gridPos = 5 * headY - 5 + headX.

    /* check out of bounds */
    Begin Check, If headX <= 0:
        Write "You lose!".
        active = 0.
    End Check.
    Begin Check, If headY <= 0:
        Write "You lose!".
        active = 0.
    End Check.
    Begin Check, If headX > 5:
        Write "You lose!".
        active = 0.
    End Check.
    Begin Check, If headY > 5:
        Write "You lose!".
        active = 0.
    End Check.

    Begin Check, If active:
        /* check for fruit */
        shorten = 1.
        Begin Check, If grid (gridPos) Is -1:
            Increment length.
            eaten = 1.
            shorten = 0.
        End Check.

        /* check for win */
        Begin Check, If length Is 25:
            Set grid To length At gridPos.
            Write output.
            Write "".
            Write "You win!".
            active = 0.
        End Check.

        Begin Check, If active:
            /* shorten snake tail */
            Begin Check, If shorten:
                index = 1.
                Begin Loop, Repeat 25 Times:
                    value = grid (index).
                    Decrement value.
                    Begin Check, If value >= 0:
                        Set grid To value At index.
                    End Check.
                    Increment index.
                End Loop.
            End Check.

            /* check collision */
            Begin Check, If grid (gridPos) > 0:
                Write "You lose!".
                active = 0.
            End Check.

            /* place snake head */
            Set grid To length At gridPos.
        End Check.
    End Check.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>tictactoe.dsl:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* tic tac toe */

grid: "0", "0", "0",
      "0", "0", "0",
      "0", "0", "0".

mapping: " ", "X", "O".

Begin Template output:
` {mapping (grid (1) + 1)} | {mapping (grid (2) + 1)} | {mapping (grid (3) + 1)}
---+---+---
 {mapping (grid (4) + 1)} | {mapping (grid (5) + 1)} | {mapping (grid (6) + 1)}
---+---+---
 {mapping (grid (7) + 1)} | {mapping (grid (8) + 1)} | {mapping (grid (9) + 1)}`
End Template.

Begin Template winMsg:
`Player {player} wins!`
End Template.

player = 1.
active = 1.

Begin Loop, While active:
    /* handle IO */
    Write output.
    Write "".
    Read input.
    Write "".

    Begin Check, If input >= 1:
        Begin Check, If input <= 9:
            Begin Check, If grid (input) Is 0:
                /* place marker */
                Set grid To player At input.

                /* check for win */
                offset = 0.
                Begin Loop, Repeat 3 Times:
                    Begin Check, If active:
                        Begin Check, If grid (1 + offset) Is player:
                            Begin Check, If grid (2 + offset) Is player:
                                Begin Check, If grid (3 + offset) Is player:
                                    Write output.
                                    Write "".
                                    Write winMsg.
                                    active = 0.
                                End Check.
                            End Check.
                        End Check.
                    End Check.
                    offset = offset + 3.
                End Loop.
                offset = 0.
                Begin Loop, Repeat 3 Times:
                    Begin Check, If active:
                        Begin Check, If grid (1 + offset) Is player:
                            Begin Check, If grid (4 + offset) Is player:
                                Begin Check, If grid (7 + offset) Is player:
                                    Write output.
                                    Write "".
                                    Write winMsg.
                                    active = 0.
                                End Check.
                            End Check.
                        End Check.
                    End Check.
                    Increment offset.
                End Loop.
                Begin Check, If active:
                    Begin Check, If grid (1) Is player:
                        Begin Check, If grid (5) Is player:
                            Begin Check, If grid (9) Is player:
                                Write output.
                                Write "".
                                Write winMsg.
                                active = 0.
                            End Check.
                        End Check.
                    End Check.
                End Check.
                Begin Check, If active:
                    Begin Check, If grid (3) Is player:
                        Begin Check, If grid (5) Is player:
                            Begin Check, If grid (7) Is player:
                                Write output.
                                Write "".
                                Write winMsg.
                                active = 0.
                            End Check.
                        End Check.
                    End Check.
                End Check.

                Begin Check, If active:
                    /* check for draw */
                    full = 1.
                    index = 1.
                    Begin Loop, Repeat 9 Times:
                        Begin Check, If grid (index) Is 0:
                            full = 0.
                        End Check.
                        Increment index.
                    End Loop.
                    Begin Check, If full:
                        active = 0.
                        Write output.
                        Write "".
                        Write "Both players tie.".
                    End Check.

                    /* toggle player */
                    player = player Mod 2 + 1.
                End Check.
            End Check.
        End Check.
    End Check.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<br>

P04: Release Candidate
======================
Generate a translator based on the desired functionality and examples.
--------------------------------
<b>Updated Grammar:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ANTLR
grammar DSL;

start : statement* EOF;

statement : ( declaration
            | operation
            | conditional | loop
            | genStmt | ioStmt ) '.';

declaration : numDec | listDec | templateDec;

numDec : ID '=' expression;

listDec : ID ':' possibleStr (',' possibleStr)*;

operation : numOp | listOp;

numOp : incOp | decOp;

incOp : 'Increment ' ID (' By ' expression)?;

decOp : 'Decrement ' ID (' By ' expression)?;

listOp : setOp | randOp;

setOp : 'Set ' ID ('(' expression ')')? ' To ' possibleStr;

randOp : 'Randomize ' ID;

templateDec : 'Begin Template ' ID ':'
              content
              'End Template';

conditional : 'Begin Check,'
              'If ' expression ':'
              statement*?
              'End Check';

loop : repeatLoop | whileLoop;

repeatLoop : 'Begin Loop,'
             ('Incrementing ' ID ',')?
             'Repeat ' expression ' Times:'
             statement*?
             'End Loop';

whileLoop : 'Begin Loop,'
            ('Incrementing ' ID ',')?
            'While ' expression ':'
            statement*?
            'End Loop';

genStmt : 'Generate ' ID;

ioStmt : readStmt | writeStmt;

readStmt : 'Read ' ID;

writeStmt : 'Write ' (possibleStr | expression);

expression : possibleNum (OP possibleNum)*;

possibleNum : NUM | ID | indexedID;

possibleStr : STR | ID | indexedID;

indexedID : ID '(' expression ')';

content : contentItem*?;

contentItem : possibleStr | BODY;

BODY : ('`' (~'`')*? '{')
     | ('}' (~'`')*? '{')
     | ('}' (~'`')*? '`')
     | ('`' (~'`')*? '`');

ID : [a-zA-Z] [a-zA-Z0-9_]*;
NUM : '-'? [0-9]+;
OP : ('+' | '-' | '*' | '/' | ' Mod '
    | ' Is ' | ' Isn\'t ' | '>=' | '<=' | '>' | '<'
    | ' And ' | ' Or ');
STR : '"' .*? '"';

COMMENT : ('/*' .*? '*/') -> skip;
WS : [ \t\r\n] -> skip;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<b>Updated Translator:</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Java
import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.RuleNode;
import org.antlr.v4.runtime.tree.TerminalNode;

import java.io.FileWriter;
import java.util.*;

public class Translator implements DSLVisitor< Integer > {
    HashMap< String, Integer > numIds = new HashMap<>();
    HashMap< String, List< String > > listIds = new HashMap<>();
    HashMap< String, DSLParser.ContentContext > templateIds = new HashMap<>();

    Scanner scanner = new Scanner(System.in);
    HashMap< String, Integer > generated = new HashMap<>();

    @Override
    public Integer visitStart(DSLParser.StartContext ctx) {
        for (DSLParser.StatementContext stmtCtx : ctx.statement()) {
            visitStatement(stmtCtx);
        }
        return null;
    }

    @Override
    public Integer visitStatement(DSLParser.StatementContext ctx) {
        if (ctx.declaration() != null) {
            visitDeclaration(ctx.declaration());
        }
        else if (ctx.operation() != null) {
            visitOperation(ctx.operation());
        }
        else if (ctx.conditional() != null) {
            visitConditional(ctx.conditional());
        }
        else if (ctx.loop() != null) {
            visitLoop(ctx.loop());
        }
        else if (ctx.genStmt() != null) {
            visitGenStmt(ctx.genStmt());
        }
        else if (ctx.ioStmt() != null) {
            visitIoStmt(ctx.ioStmt());
        }
        return null;
    }

    @Override
    public Integer visitDeclaration(DSLParser.DeclarationContext ctx) {
        if (ctx.numDec() != null) {
            visitNumDec(ctx.numDec());
        }
        else if (ctx.listDec() != null) {
            visitListDec(ctx.listDec());
        }
        else if (ctx.templateDec() != null) {
            visitTemplateDec(ctx.templateDec());
        }
        return null;
    }

    @Override
    public Integer visitNumDec(DSLParser.NumDecContext ctx) {
        String numId = ctx.ID().getText();
        Integer exprResult = visitExpression(ctx.expression());
        if (exprResult != null) {
            if (listIds.containsKey(numId) || templateIds.containsKey(numId)) {
                throw new RuntimeException(String.format("\"%s\" is already defined with a different type", numId));
            }
            else {
                numIds.put(numId, exprResult);
            }
        }
        else {
            throw new RuntimeException(String.format("initializer for \"%s\" evaluated to null (expected an integer)", numId));
        }
        return null;
    }

    @Override
    public Integer visitListDec(DSLParser.ListDecContext ctx) {
        String listId = ctx.ID().getText();
        List< String > strList = new ArrayList<>();

        for (DSLParser.PossibleStrContext strCtx : ctx.possibleStr()) {
            visitPossibleStr(strCtx);
            if (possibleStrResult != null) {
                strList.add(possibleStrResult);
            }
            else {
                throw new RuntimeException(String.format("initializer for an element in \"%s\" evaluated to null (expected a string)", listId));
            }
        }

        if (numIds.containsKey(listId) || templateIds.containsKey(listId)) {
            throw new RuntimeException(String.format("\"%s\" is already defined with a different type", listId));
        }
        else {
            listIds.put(listId, strList);
        }

        return null;
    }

    @Override
    public Integer visitOperation(DSLParser.OperationContext ctx) {
        if (ctx.numOp() != null) {
            visitNumOp(ctx.numOp());
        }
        else if (ctx.listOp() != null) {
            visitListOp(ctx.listOp());
        }
        return null;
    }

    @Override
    public Integer visitNumOp(DSLParser.NumOpContext ctx) {
        if (ctx.incOp() != null) {
            visitIncOp(ctx.incOp());
        }
        else if (ctx.decOp() != null) {
            visitDecOp(ctx.decOp());
        }
        return null;
    }

    @Override
    public Integer visitIncOp(DSLParser.IncOpContext ctx) {
        String numID = ctx.ID().getText();
        if (numIds.containsKey(numID)) {
            int incVal = 1;
            if (ctx.expression() != null) {
                Integer exprResult = visitExpression(ctx.expression());
                if (exprResult == null) {
                    throw new RuntimeException("expression in increment statement evaluated to null");
                }
                else {
                    incVal = exprResult;
                }
            }
            numIds.put(numID, numIds.get(numID) + incVal);
        }
        else {
            throw new RuntimeException(String.format("no numeric variable named \"%s\" has been declared", numID));
        }
        return null;
    }

    @Override
    public Integer visitDecOp(DSLParser.DecOpContext ctx) {
        String numID = ctx.ID().getText();
        if (numIds.containsKey(numID)) {
            int decVal = 1;
            if (ctx.expression() != null) {
                Integer exprResult = visitExpression(ctx.expression());
                if (exprResult == null) {
                    throw new RuntimeException("expression in increment statement evaluated to null");
                }
                else {
                    decVal = exprResult;
                }
            }
            numIds.put(numID, numIds.get(numID) - decVal);
        }
        else {
            throw new RuntimeException(String.format("no numeric variable named \"%s\" has been declared", numID));
        }
        return null;
    }

    @Override
    public Integer visitListOp(DSLParser.ListOpContext ctx) {
        if (ctx.setOp() != null) {
            visitSetOp(ctx.setOp());
        }
        else if (ctx.randOp() != null) {
            visitRandOp(ctx.randOp());
        }
        return null;
    }

    @Override
    public Integer visitSetOp(DSLParser.SetOpContext ctx) {
        String listId = ctx.ID().getText();
        if (listIds.containsKey(listId)) {
            Integer listIndex;

            if (ctx.expression() != null) {
                listIndex = visitExpression(ctx.expression());
            }
            else {
                listIndex = 1;
            }

            if (listIndex == null) {
                throw new RuntimeException(String.format("index for \"%s\" evaluated to null (expected a 1-based integer)", listId));
            }
            else if (listIndex >= 1 && listIndex <= listIds.get(listId).size()) {
                visitPossibleStr(ctx.possibleStr());
                if (possibleStrResult != null) {
                    listIds.get(listId).set(listIndex - 1, possibleStrResult);
                }
                else {
                    throw new RuntimeException(String.format("assignment to \"%s[%d]\" evaluated to null (lists cannot store null strings)", listId, listIndex));
                }
            }
            else {
                throw new RuntimeException(String.format("index %d is out of bounds (valid range for \"%s\" is 1 to %d)", listIndex, listId, listIds.get(listId).size()));
            }
        }
        else {
            throw new RuntimeException(String.format("no list named \"%s\" has been declared", listId));
        }
        return null;
    }

    @Override
    public Integer visitRandOp(DSLParser.RandOpContext ctx) {
        String listId = ctx.ID().getText();
        if (listIds.containsKey(listId)) {
            Collections.shuffle(listIds.get(listId));
        }
        else {
            throw new RuntimeException(String.format("no list named \"%s\" has been declared", listId));
        }
        return null;
    }

    @Override
    public Integer visitTemplateDec(DSLParser.TemplateDecContext ctx) {
        String templateId = ctx.ID().getText();
        if (numIds.containsKey(templateId) || listIds.containsKey(templateId)) {
            throw new RuntimeException(String.format("\"%s\" is already defined with a different type", templateId));
        }
        else {
            templateIds.put(templateId, ctx.content());
        }
        return null;
    }

    @Override
    public Integer visitConditional(DSLParser.ConditionalContext ctx) {
        Integer exprResult = visitExpression(ctx.expression());
        if (exprResult == null) {
            throw new RuntimeException("condition in check block evaluated to null (expected 0 or 1)");
        }
        else if (exprResult == 1) { // true
            for (DSLParser.StatementContext stmtCtx : ctx.statement()) {
                visitStatement(stmtCtx);
            }
        }
        else if (exprResult != 0) { // not true or false
            throw new RuntimeException(String.format("condition in check block evaluated to %d (expected 0 or 1)", exprResult));
        }
        return null;
    }

    @Override
    public Integer visitLoop(DSLParser.LoopContext ctx) {
        if (ctx.repeatLoop() != null) {
            visitRepeatLoop(ctx.repeatLoop());
        }
        else if (ctx.whileLoop() != null) {
            visitWhileLoop(ctx.whileLoop());
        }
        return null;
    }
    
    private void createIncrementor(String incId) {
        if (listIds.containsKey(incId) || templateIds.containsKey(incId)) {
            throw new RuntimeException(String.format("incrementor \"%s\" is already defined with a different type", incId));
        }
        else {
            numIds.put(incId, 1);
        }
    }

    @Override
    public Integer visitRepeatLoop(DSLParser.RepeatLoopContext ctx) {
        String incId = null;
        if (ctx.ID() != null) {
            incId = ctx.ID().getText();
            createIncrementor(incId);
        }

        Integer exprResult = visitExpression(ctx.expression());
        if (exprResult == null) {
            throw new RuntimeException("repeat loop count evaluated to null (expected >= 0)");
        }
        else if (exprResult >= 0) {
            for (int i = 0; i < exprResult; i++) {
                for (DSLParser.StatementContext stmtCtx : ctx.statement()) {
                    visitStatement(stmtCtx);
                }

                if (incId != null) {
                    numIds.put(incId, numIds.get(incId) + 1);
                }
            }
        }
        else {
            throw new RuntimeException(String.format("repeat loop count is %d (expected >= 0)", exprResult));
        }
        return null;
    }

    @Override
    public Integer visitWhileLoop(DSLParser.WhileLoopContext ctx) {
        String incId = null;
        if (ctx.ID() != null) {
            incId = ctx.ID().getText();
            createIncrementor(incId);
        }

        int iter = 0;
        Integer exprResult;
        while (true) {
            exprResult = visitExpression(ctx.expression());
            if (exprResult == null) {
                throw new RuntimeException("while condition evaluated to null (expected 0 or 1)");
            }
            else if (exprResult == 0) {
                break;
            }
            else if (exprResult == 1) {
                if (iter >= 1000) {
                    throw new RuntimeException("while loop exceeded 1000 iterations (possible infinite loop)");
                }

                for (DSLParser.StatementContext stmtCtx : ctx.statement()) {
                    visitStatement(stmtCtx);
                }

                if (incId != null) {
                    numIds.put(incId, numIds.get(incId) + 1);
                }

                iter++;
            }
            else {
                throw new RuntimeException(String.format("while condition evaluated to %d (expected 0 or 1)", exprResult));
            }
        }

        return null;
    }

    @Override
    public Integer visitGenStmt(DSLParser.GenStmtContext ctx) {
        String templateId = ctx.ID().getText();
        if (templateIds.containsKey(templateId)) {
            visitContent(templateIds.get(templateId));
            if (contentResult != null) {
                if (!generated.containsKey(templateId)) {
                    generated.put(templateId, 1);
                }
                try {
                    String file = templateId + "_" + generated.get(templateId);
                    FileWriter fileOutput = new FileWriter("out/" + file);
                    fileOutput.write(contentResult);
                    fileOutput.close();
                    System.out.println("Generated " + file);
                }
                catch (Exception e) {
                    throw new RuntimeException(e);
                }
                generated.put(templateId, generated.get(templateId) + 1);
            }
            else {
                throw new RuntimeException(String.format("template \"%s\" produced null content (check placeholders)", templateId));
            }
        }
        else {
            throw new RuntimeException(String.format("no template named \"%s\" has been declared", templateId));
        }
        return null;
    }

    @Override
    public Integer visitIoStmt(DSLParser.IoStmtContext ctx) {
        if (ctx.readStmt() != null) {
            visitReadStmt(ctx.readStmt());
        }
        else if (ctx.writeStmt() != null) {
            visitWriteStmt(ctx.writeStmt());
        }
        return null;
    }

    @Override
    public Integer visitReadStmt(DSLParser.ReadStmtContext ctx) {
        String id = ctx.ID().getText();
        if (numIds.containsKey(id) || templateIds.containsKey(id)) {
            throw new RuntimeException(String.format("\"%s\" is already defined with a different type", id));
        }
        else {
            System.out.print("Input: ");
            listIds.put(id, new ArrayList<>(
                    Collections.singletonList(scanner.nextLine())
            ));
        }
        return null;
    }

    @Override
    public Integer visitWriteStmt(DSLParser.WriteStmtContext ctx) {
        if (ctx.possibleStr() != null) {
            visitPossibleStr(ctx.possibleStr());
            if (possibleStrResult != null) {
                System.out.println(possibleStrResult);
            }
            else {
                throw new RuntimeException("write statement evaluated to null (expected a string)");
            }
        }
        else if (ctx.expression() != null) {
            Integer exprResult = visitExpression(ctx.expression());
            if (exprResult != null) {
                System.out.println(exprResult);
            }
            else {
                throw new RuntimeException("write statement evaluated to null (expected an integer)");
            }
        }
        return null;
    }

    @Override
    public Integer visitExpression(DSLParser.ExpressionContext ctx) {
        List< DSLParser.PossibleNumContext > nums = ctx.possibleNum();
        List< TerminalNode > ops  = ctx.OP();

        Integer value = visitPossibleNum(nums.get(0));
        if (value == null) {
            throw new RuntimeException("expression segment resolved to null");
        }

        for (int i = 1; i < nums.size(); i++) {
            Integer next = visitPossibleNum(nums.get(i));
            if (next == null) {
                throw new RuntimeException("expression segment resolved to null");
            }
            else {
                switch (ops.get(i - 1).getText().replaceAll(" ", "")) {
                    case "+":
                        value += next;
                        break;
                    case "-":
                        value -= next;
                        break;
                    case "*":
                        value *= next;
                        break;
                    case "/":
                        if (next != 0) {
                            value /= next;
                        }
                        else {
                            throw new RuntimeException("attempted division by zero in expression");
                        }
                        break;
                    case "Mod":
                        if (next != 0) {
                            value %= next;
                        }
                        else {
                            throw new RuntimeException("attempted modulus by zero in expression");
                        }
                        break;
                    case "Is":
                        value = (value.equals(next)) ? 1 : 0;
                        break;
                    case "Isn't":
                        value = (value.equals(next)) ? 0 : 1;
                        break;
                    case ">=":
                        value = (value >= next) ? 1 : 0;
                        break;
                    case "<=":
                        value = (value <= next) ? 1 : 0;
                        break;
                    case ">":
                        value = (value > next) ? 1 : 0;
                        break;
                    case "<":
                        value = (value < next) ? 1 : 0;
                        break;
                    case "And":
                        if (isBoolean(value) && isBoolean(next)) {
                            value = (value == 1 && next == 1) ? 1 : 0;
                        }
                        else {
                            throw new RuntimeException(String.format("logical operator received %d and %d (expected 0 or 1)", value, next));
                        }
                        break;
                    case "Or":
                        if (isBoolean(value) && isBoolean(next)) {
                            value = (value == 1 || next == 1) ? 1 : 0;
                        }
                        else {
                            throw new RuntimeException(String.format("logical operator received %d and %d (expected 0 or 1)", value, next));
                        }
                        break;
                    default:
                        throw new RuntimeException(String.format("unrecognised operator \"%s\"", ops.get(i - 1).getText()));
                }
            }
        }

        return value;
    }

    private static boolean isBoolean(int v) {
        return v == 0 || v == 1;
    }

    @Override
    public Integer visitPossibleNum(DSLParser.PossibleNumContext ctx) {
        if (ctx.NUM() != null) {
            return Integer.parseInt(ctx.NUM().getText());
        }

        if (ctx.ID() != null) {
            String numId = ctx.ID().getText();
            if (numIds.containsKey(numId)) {
                return numIds.get(numId);
            }
            else {
                if (listIds.containsKey(numId)) {
                    try {
                        return Integer.parseInt(listIds.get(numId).get(0));
                    }
                    catch (NumberFormatException e) {
                        throw new RuntimeException(String.format("first element of list \"%s\" is not a valid integer", numId));
                    }
                }
                else {
                    throw new RuntimeException(String.format("identifier \"%s\" is undefined", numId));
                }
            }
        }
        else if (ctx.indexedID() != null) {
            visitIndexedID(ctx.indexedID());
            if (possibleIndexingResult != null) {
                try {
                    return Integer.parseInt(possibleIndexingResult);
                }
                catch (NumberFormatException e) {
                    throw new RuntimeException(String.format("value at \"%s[index]\" is not an integer", ctx.indexedID().ID().getText()));
                }
            }
            else {
                throw new RuntimeException(String.format("evaluation of \"%s(index)\" returned null", ctx.indexedID().ID().getText()));
            }
        }

        return null;
    }

    String possibleStrResult = null;

    @Override
    public Integer visitPossibleStr(DSLParser.PossibleStrContext ctx) {
        possibleStrResult = null;
        if (ctx.STR() != null) {
            possibleStrResult = ctx.STR().getText().replaceAll("\"", "");
        }
        else if (ctx.ID() != null) {
            String id = ctx.ID().getText();
            if (listIds.containsKey(id)) {
                possibleStrResult = listIds.get(id).get(0);
            }
            else if (numIds.containsKey(id)) {
                possibleStrResult = String.valueOf(numIds.get(id));
            }
            else if (templateIds.containsKey(id)) {
                visitContent(templateIds.get(id));
                if (contentResult != null) {
                    possibleStrResult = contentResult;
                }
                else {
                    throw new RuntimeException(String.format("template \"%s\" produced null content (check placeholders)", id));
                }
            }
            else {
                throw new RuntimeException(String.format("identifier \"%s\" is undefined", id));
            }
        }
        else if (ctx.indexedID() != null) {
            visitIndexedID(ctx.indexedID());
            if (possibleIndexingResult != null) {
                possibleStrResult = possibleIndexingResult;
            }
            else {
                throw new RuntimeException(String.format("evaluation of \"%s(index)\" returned null", ctx.indexedID().ID().getText()));
            }
        }
        return null;
    }

    String contentResult = null;

    @Override
    public Integer visitContent(DSLParser.ContentContext ctx) {
        contentResult = "";
        for (DSLParser.ContentItemContext itemCtx : ctx.contentItem()) {
            visitContentItem(itemCtx);
            if (itemResult != null) {
                contentResult += itemResult;
            }
            else {
                contentResult = null;
                throw new RuntimeException("template content contains a null segment");
            }
        }
        return null;
    }

    String itemResult = null;

    @Override
    public Integer visitContentItem(DSLParser.ContentItemContext ctx) {
        itemResult = null;
        if (ctx.possibleStr() != null) {
            visitPossibleStr(ctx.possibleStr());
            if (possibleStrResult != null) {
                itemResult = possibleStrResult;
            }
            else {
                throw new RuntimeException("template content contains a null segment");
            }
        }
        else if (ctx.BODY() != null) {
            itemResult = ctx.BODY().getText()
                    .replaceAll("`", "")
                    .replaceAll("\\{", "")
                    .replaceAll("}", "");
        }
        return null;
    }

    String possibleIndexingResult = null;

    @Override
    public Integer visitIndexedID(DSLParser.IndexedIDContext ctx) {
        possibleIndexingResult = null;
        String listId = ctx.ID().getText();
        if (listIds.containsKey(listId)) {
            Integer listIndex = visitExpression(ctx.expression());
            if (listIndex != null) {
                if (listIndex >= 1 && listIndex <= listIds.get(listId).size()) {
                    possibleIndexingResult = listIds.get(listId).get(listIndex - 1);
                }
                else {
                    throw new RuntimeException(String.format("index %d is out of bounds (valid range for \"%s\" is 1 to %d)", listIndex, listId, listIds.get(listId).size()));
                }
            }
            else {
                throw new RuntimeException(String.format("list index for \"%s\" evaluated to null (expected >= 1)", listId));
            }
        }
        else {
            throw new RuntimeException(String.format("no list named \"%s\" has been declared", listId));
        }
        return null;
    }

    @Override public Integer visit(ParseTree tree) { return null; }
    @Override public Integer visitChildren(RuleNode node) { return null; }
    @Override public Integer visitTerminal(TerminalNode node) { return null; }
    @Override public Integer visitErrorNode(ErrorNode node) { return null; }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The most significant changes this milestone were: (1) creating output files containing generated mails (instead of just printing them to console), (2) expanding the syntax of the increment statement to allow for incrementing "by" an expression, and (3) creating a way of specify "incrementers" (similar to the third part of a for loop, e.g., i++), which makes writing programs for non-programmers simpler. We also packaged our project into a .jar file which can be run from the command line using: "java -jar Interpreter.jar {input file here}". This file is included in the release folder. 

Furthermore, we created a Python file to actually send the generated emails, using the documentation as a reference on how to do this. It requires a Gmail address and app password, which should be placed into login.txt (provide this file as an input to the program when it asks, alongside the directory of emails to send). The program is located in the release folder alongside the interpreter, and is copied below:

<b>dir2email.py</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Python
import os
import smtplib
from email.message import EmailMessage

# CITATION: referenced https://docs.python.org/3/library/email.examples.html
def send(sender, password, recipient, subject, body):
    msg = EmailMessage()
    msg.set_content(body)
    msg["Subject"] = subject
    msg["From"] = sender
    msg["To"] = recipient
    
    with smtplib.SMTP_SSL("smtp.gmail.com", 465) as s:
        s.login(sender, password)
        s.send_message(msg)

directory = input("Directory: ").strip()
login_file = input("Login File: ").strip()

with open(login_file, encoding="utf-8") as f:
    sender = f.readline().strip()
    password = f.readline().strip()

for file in os.listdir(directory):
    path = os.path.join(directory, file)
    if not (os.path.isfile(path) and file.endswith(".txt")):
        continue

    with open(path, encoding="utf-8") as fp:
        content = fp.read()
    
    print(f"\n=== {file} ===\n{content}\n")
    subject = input("Subject: ").strip()
    recipient = input("Recipient: ").strip()
    
    if recipient:
        try:
            send(sender, password, recipient, subject, content)
            print(f"\nSent '{subject}' to {recipient}")
        except Exception as e:
            print(f"\nFailed to send '{subject}' to {recipient}: {e}")

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

See the bottom of the next section for screenshots of this program being run. 

Translate all your valid inputs (trivial and non-trivial).
--------------------------------
Our input files were modified to use the new "incrementer" construct whenever possible. Here is an example:

<b>taskassign</b>
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DSL
/* task assignment */

recipient: "John", "Joe", "James", "Jessie".
project: "website", "desktop app".
platform: "Mac", "Windows".

Randomize recipient.

Begin Template task_mail:
`Dear {recipient (c)},

Your task is to create a {project (i)} for {platform (j)}.

Sincerely,
Jeffery`
End Template.

c = 1.

Begin Loop, Incrementing i, Repeat 2 Times:
    Begin Loop, Incrementing j, Repeat 2 Times:
        Generate task_mail.
        Increment c.
    End Loop.
End Loop.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We tested that our language worked as intended on all of our previously created and modified inputs. We automated testing the parsing step using ParseTest.java (created in a previous milestone), and manually tested the translator using Interpreter.jar. Everywhere that our translator could run into a runtime error, we added a custom exception message. 

<br>

Our language is also now able to perfectly run snake and tictactoe:

<b>Snake Program:</b><br>
![](screenshots/p04_snake.png)

<b>Tictactoe Program:</b><br>
![](screenshots/p04_tictactoe.png)

<br>

The Python script that we made is able to send actual emails (they sometimes get filtered as junk, though it's understandable why this happens; this sort of filtering also prevents spam from bots). See the screenshots below:

<b>Python Program:</b><br>
![](screenshots/p04_python.png)

<b>My Inbox:</b><br>
![](screenshots/p04_inbox.png)

Properly and gracefully handles invalid inputs (trivial and non-trivial).
--------------------------------
For syntactically invalid inputs, ANTLR is able to precisely identify where parsing failed (this is fairly trivial as it doesn't require any special effort on our part):

<b>Syntax Error</b><br>
![](screenshots/p04_syntaxerror.png)

<br>

For all runtime errors we could think of, we wrote a corresponding exception message. We tried to be as specific as possible about the exception (such as including identifiers and expected values wherever relevant). Many of these errors and examples of invalid inputs are shown in the previous milestone. Here is one example: 

<b>Out of Bounds Error</b><br>
![](screenshots/p04_ooberror.png)

<br>

For nontrivial inputs such as our snake program, our programs is still able to reasonably handle failure such as unexpected user inputs.:

<b>Snake Error</b><br>
![](screenshots/p04_snakeerror.png)

<br>

P05: Final
================
New readme.html contains the language's documentation.

<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>